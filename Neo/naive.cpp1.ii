#line 1 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"
#line 1 "C:\\CUDA\\include\\cuda_runtime.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\host_config.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/














#line 59 "c:\\cuda\\include\\host_config.h"





#line 65 "c:\\cuda\\include\\host_config.h"









#line 75 "c:\\cuda\\include\\host_config.h"





#line 81 "c:\\cuda\\include\\host_config.h"





#line 87 "c:\\cuda\\include\\host_config.h"

#line 89 "c:\\cuda\\include\\host_config.h"





#line 95 "c:\\cuda\\include\\host_config.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 





#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"














#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Security Enhancements in the CRT".
*/











    

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/

#pragma once
/*==========================================================================

   The macros are defined in 3 layers:

   _In_\_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_\_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_\_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ\Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.
   
   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2
   
   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/



// choose attribute or __declspec implementation













#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"

















// safeguard for MIDL and RC builds



#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"



#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"

//============================================================================
//   _In_\_Out_ Layer:
//============================================================================

// 'in' parameters --------------------------

// input pointer parameter
// e.g. void SetPoint( _In_ const POINT* pPT );



// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );



// 'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter





// valid buffer extent described by a constant extression





// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter





// nullterminated valid buffer extent described by a constant extression





// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );





// 'out' parameters --------------------------

// output pointer parameter
// e.g. void GetPoint( _Out_ POINT* pPT );



// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression





// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );





// only use with dereferenced arguments e.g. '*pcch' 










// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );





// inout parameters ----------------------------

// inout pointer parameter
// e.g. void ModifyPoint( _Inout_ POINT* pPT );



// string buffers
// e.g. void toupper( _Inout_z_ char* sz );



// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );










// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );


















// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );















// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );















// return values -------------------------------

// returning pointers to valid objects



// More _Ret_ annotations are defined below

// Pointer to pointers -------------------------

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );





// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );





// More _Deref_ annotations are defined below

// Other annotations

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();


// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );




// <expr> indicates whether post conditions apply


// annotations to express 'boundedness' of integral value parameter








// annotations to express upper and lower bounds of integral value parameter







//============================================================================
//   _Pre_\_Post_ Layer:
//============================================================================

//
// _Pre_ annotation ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string



// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter





// buffer capacity described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression



// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);



// buffer capacity described by a complex condition





// buffer capacity described by the difference to another pointer parameter



// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );















// known capacity and valid but unknown readable extent















// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter





// Valid buffer extent described by a constant expression





// Valid buffer extent described by a complex expression





// Valid buffer extent described by the difference to another pointer parameter



// valid size unknown or indicated by type (e.g.:LPSTR)





// used with allocated but not yet initialized objects




// restrict access rights


//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call


// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call


// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );



// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );







// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );







// e.g. void free( _Post_invalid_ void* pv );



// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );


//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();



// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter





// Buffer capacity is described by a constant expression





// Buffer capacity is described by a complex condition





// return value is nullterminated and capacity is given by another parameter





// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter





// Valid Buffer extent is described by a constant expression





// Valid Buffer extent is described by a complex expression





// return value is nullterminated and length is given by another parameter





// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );



// used with allocated but not yet initialized objects




//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );



// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex condition





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n ); 
// valid buffer extent is described by another parameter





// valid buffer extent is described by a constant expression





// valid buffer extent is described by a complex expression





// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );








// restrict access rights



//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );



// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent




                                                




                                                





// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );







//
// _Deref_ret_ ---
//




//
// special _Deref_ ---
//


// Convenience macros for more concise annotations

//
// _Pre_post ---
//
// describing conditions that hold before and after the function call




















//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call










































//
// _Deref_<miscellaneous>
//
// used with references to arrays







//============================================================================
//   Implementation Layer:
//============================================================================

























































































#line 1019 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"































































































#line 1115 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"



































































































#line 1215 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"



















































#line 1267 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"

// This section contains the deprecated annotations

/* 
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz	 : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     LPCSTR pszString,                    -- No annotation required, const implies __in.
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     LPCSTR pszSrc,                       -- No annotation required, const implies __in.
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return == TRUE) LWSTDAPI_(BOOL) 
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/






#line 1479 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"
extern "C" {




#line 1485 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
The helper annotations are only understood by the compiler version used by various
defect detection tools. When the regular compiler is running, they are defined into
nothing, and do not affect the compiled code.
*/












































































































































































































#line 1706 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 1740 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"

/* 
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/

































































































































































































/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/















    
    
#line 1970 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"






#line 1977 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"
#line 1978 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"


}
#line 1982 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\sal.h"



#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



































































































#pragma pack(push,8)
#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"
/***
*vadefs.h - defines helper macros for stdarg.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is a helper file for stdarg.h
*
*       [Public]
*
****/


#pragma once
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"






#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"



/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */


#pragma pack(push,8)
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"


extern "C" {
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"





#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"

#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"



typedef unsigned __int64    uintptr_t;


#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"

#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"





typedef char *  va_list;
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"

#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"





#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"











#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"


#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"













#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"







#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"














#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"


extern void __cdecl __va_start(va_list *, ...);


















#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"


}
#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"


#pragma pack(pop)
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"

#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\vadefs.h"
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


extern "C" {
#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* preprocessor string helpers */



#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"







#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


/* Define _CRTIMP_NOIA64 */



#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 209 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRTIMP2 */




#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRTIMP_ALTERNATIVE */











#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _MRTIMP */



#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _MRTIMP2 */





#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"







#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


 

#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
  
 #line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"










#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* define a specific constant for mixed mode */






/* Define __STDC_SECURE_LIB__ */


/* Retain__GOT_SECURE_LIB__ for back-compat */


/* Default value for __STDC_WANT_SECURE_LIB__ is 1 */


#line 324 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Turn off warnings if __STDC_WANT_SECURE_LIB__ is 0 */


#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* See note on use of deprecate at the top of this file */




#line 336 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRT_INSECURE_DEPRECATE */
/* See note on use of deprecate at the top of this file */


#line 342 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRT_INSECURE_DEPRECATE_MEMORY */
/* See note on use of deprecate at the top of this file */


#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRT_INSECURE_DEPRECATE_GLOBALS */
/* See note on use of deprecate at the top of this file */



#line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 382 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRT_MANAGED_HEAP_DEPRECATE */
/* See note on use of deprecate at the top of this file */


#line 390 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"










#line 401 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 403 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Change the __FILL_BUFFER_PATTERN to 0xFE to fix security function buffer overrun detection bug */


/* obsolete stuff */

/* Define _CRT_OBSOLETE */
/* See note on use of deprecate at the top of this file */


#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


/* jit64 instrinsic stuff */




#line 432 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define overload switches */

 
  
 



#line 445 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


 
  /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0 */
  
 



#line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


 
  
   
  

#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
 



#line 470 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 471 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRT_NONSTDC_DEPRECATE */
/* See note on use of deprecate at the top of this file */


#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 484 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



typedef unsigned __int64    size_t;


#line 492 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



typedef size_t rsize_t;

#line 500 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 501 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



typedef __int64             intptr_t;


#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 510 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"












typedef __int64             ptrdiff_t;


#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 528 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"







typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 539 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



















/* errcode is deprecated in favor or errno_t, which is part of the standard proposal */

__declspec(deprecated("This name was supported during some Whidbey pre-releases. Instead, use the standard name errno_t.")) typedef int errcode;


#line 564 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

typedef int errno_t;
#line 567 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


typedef  long __time32_t;   /* 32-bit time value */

#line 572 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


typedef __int64 __time64_t;     /* 64-bit time value */

#line 577 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"





typedef __time64_t time_t;      /* time value */
#line 584 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 586 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"







#line 594 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 595 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 602 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 603 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 608 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define _CRTNOALIAS, _CRTRESTRICT */




#line 618 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 619 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 624 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 628 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"











#line 640 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* Define __cdecl for non-Microsoft compilers */


#line 645 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




#line 650 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 652 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 653 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"




/* _TRUNCATE */


#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

/* helper macros for cpp overloads */
































































































































































#line 824 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 825 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1891 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"















































































































































#line 2035 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
#line 2036 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;

#line 2057 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;

#line 2086 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


}
#line 2090 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 2094 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 2096 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 2100 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 2102 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 2106 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 2108 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"






#line 2115 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"



#line 2119 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"


#pragma pack(pop)
#line 2123 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 2125 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"

#line 97 "c:\\cuda\\include\\host_config.h"



#line 101 "c:\\cuda\\include\\host_config.h"

#line 103 "c:\\cuda\\include\\host_config.h"

#line 105 "c:\\cuda\\include\\host_config.h"
#line 46 "C:\\CUDA\\include\\cuda_runtime.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
enum cudaRoundMode
{
  cudaRoundNearest,
  cudaRoundZero,
  cudaRoundPosInf,
  cudaRoundMinInf
};

#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/**
 * \file
 * \name Data types used by CUDA Runtime
 * \author NVIDIA Corporation
 * \brief Data types used by CUDA Runtime
 */
/**
 * \defgroup CUDART_TYPES Data types used by CUDA Runtime
 * \ingroup CUDART
 *
 * @{
 */

/*******************************************************************************
*                                                                              *
*  TYPE DEFINITIONS USED BY RUNTIME API                                        *
*                                                                              *
*******************************************************************************/



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
/***
*limits.h - implementation dependent values
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/


#pragma once
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
















#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"



























/* minimum signed 64 bit value */

/* maximum signed 64 bit value */

/* maximum unsigned 64 bit value */









#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"






#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"


/* While waiting to the C standard committee to finalize the decision on RSIZE_MAX and rsize_t,
 * we define RSIZE_MAX as SIZE_MAX
 */


#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
































#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\limits.h"
#line 61 "c:\\cuda\\include\\driver_types.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/


#pragma once
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"


extern "C" {
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"

/* Define NULL pointer value */





#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"


/* Declare reference to errno */


 extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(  int _Value);
errno_t __cdecl _get_errno(  int * _Value);
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"

/* Define offsetof macro */






#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"









#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"


 extern unsigned long  __cdecl __threadid(void);

 extern uintptr_t __cdecl __threadhandle(void);
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"



}
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"

#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stddef.h"
#line 62 "c:\\cuda\\include\\driver_types.h"




















#line 83 "c:\\cuda\\include\\driver_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * CUDA error types
 */
/*DEVICE_BUILTIN*/
enum cudaError
{
  cudaSuccess                           =      0,   ///< No errors
  cudaErrorMissingConfiguration         =      1,   ///< Missing configuration error
  cudaErrorMemoryAllocation             =      2,   ///< Memory allocation error
  cudaErrorInitializationError          =      3,   ///< Initialization error
  cudaErrorLaunchFailure                =      4,   ///< Launch failure
  cudaErrorPriorLaunchFailure           =      5,   ///< Prior launch failure
  cudaErrorLaunchTimeout                =      6,   ///< Launch timeout error
  cudaErrorLaunchOutOfResources         =      7,   ///< Launch out of resources error
  cudaErrorInvalidDeviceFunction        =      8,   ///< Invalid device function
  cudaErrorInvalidConfiguration         =      9,   ///< Invalid configuration
  cudaErrorInvalidDevice                =     10,   ///< Invalid device
  cudaErrorInvalidValue                 =     11,   ///< Invalid value
  cudaErrorInvalidPitchValue            =     12,   ///< Invalid pitch value
  cudaErrorInvalidSymbol                =     13,   ///< Invalid symbol
  cudaErrorMapBufferObjectFailed        =     14,   ///< Map buffer object failed
  cudaErrorUnmapBufferObjectFailed      =     15,   ///< Unmap buffer object failed
  cudaErrorInvalidHostPointer           =     16,   ///< Invalid host pointer
  cudaErrorInvalidDevicePointer         =     17,   ///< Invalid device pointer
  cudaErrorInvalidTexture               =     18,   ///< Invalid texture
  cudaErrorInvalidTextureBinding        =     19,   ///< Invalid texture binding
  cudaErrorInvalidChannelDescriptor     =     20,   ///< Invalid channel descriptor
  cudaErrorInvalidMemcpyDirection       =     21,   ///< Invalid memcpy direction
  cudaErrorAddressOfConstant            =     22,   ///< Address of constant error
                                                    ///< \deprecated
                                                    ///< This error return is deprecated as of
                                                    ///< Cuda 3.1. Variables in constant memory
                                                    ///< may now have their address taken by the
                                                    ///< runtime via ::cudaGetSymbolAddress().
  cudaErrorTextureFetchFailed           =     23,   ///< Texture fetch failed
  cudaErrorTextureNotBound              =     24,   ///< Texture not bound error
  cudaErrorSynchronizationError         =     25,   ///< Synchronization error
  cudaErrorInvalidFilterSetting         =     26,   ///< Invalid filter setting
  cudaErrorInvalidNormSetting           =     27,   ///< Invalid norm setting
  cudaErrorMixedDeviceExecution         =     28,   ///< Mixed device execution
  cudaErrorCudartUnloading              =     29,   ///< CUDA runtime unloading
  cudaErrorUnknown                      =     30,   ///< Unknown error condition
  cudaErrorNotYetImplemented            =     31,   ///< Function not yet implemented
  cudaErrorMemoryValueTooLarge          =     32,   ///< Memory value too large
  cudaErrorInvalidResourceHandle        =     33,   ///< Invalid resource handle
  cudaErrorNotReady                     =     34,   ///< Not ready error
  cudaErrorInsufficientDriver           =     35,   ///< CUDA runtime is newer than driver
  cudaErrorSetOnActiveProcess           =     36,   ///< Set on active process error
  cudaErrorInvalidSurface               =     37,   ///< Invalid surface
  cudaErrorNoDevice                     =     38,   ///< No Cuda-capable devices detected
  cudaErrorECCUncorrectable             =     39,   ///< Uncorrectable ECC error detected
  cudaErrorSharedObjectSymbolNotFound   =     40,   ///< Link to a shared object failed to resolve
  cudaErrorSharedObjectInitFailed       =     41,   ///< Shared object initialization failed
  cudaErrorUnsupportedLimit             =     42,   ///< ::cudaLimit not supported by device
  cudaErrorDuplicateVariableName        =     43,   ///< Duplicate global variable lookup by string name
  cudaErrorDuplicateTextureName         =     44,   ///< Duplicate texture lookup by string name
  cudaErrorDuplicateSurfaceName         =     45,   ///< Duplicate surface lookup by string name
  cudaErrorDevicesUnavailable           =     46,   ///< All Cuda-capable devices are busy (see ::cudaComputeMode) or unavailable
  cudaErrorStartupFailure               =   0x7f,   ///< Startup failure
  cudaErrorApiFailureBase               =  10000    ///< API failure base
};

/**
 * Channel format kind
 */
/*DEVICE_BUILTIN*/
enum cudaChannelFormatKind
{
  cudaChannelFormatKindSigned           =   0,      ///< Signed channel format
  cudaChannelFormatKindUnsigned         =   1,      ///< Unsigned channel format
  cudaChannelFormatKindFloat            =   2,      ///< Float channel format
  cudaChannelFormatKindNone             =   3       ///< No channel format
};

/**
 * CUDA Channel format descriptor
 */
/*DEVICE_BUILTIN*/
struct cudaChannelFormatDesc
{
  int                        x; ///< x
  int                        y; ///< y
  int                        z; ///< z
  int                        w; ///< w
  enum cudaChannelFormatKind f; ///< Channel format kind
};

/**
 * CUDA array
 */
/*DEVICE_BUILTIN*/
struct cudaArray;

/**
 * CUDA memory copy types
 */
/*DEVICE_BUILTIN*/
enum cudaMemcpyKind
{
  cudaMemcpyHostToHost          =   0,      ///< Host   -> Host
  cudaMemcpyHostToDevice        =   1,      ///< Host   -> Device
  cudaMemcpyDeviceToHost        =   2,      ///< Device -> Host
  cudaMemcpyDeviceToDevice      =   3       ///< Device -> Device
};

/**
 * CUDA Pitched memory pointer
 * \sa ::make_cudaPitchedPtr
 */
/*DEVICE_BUILTIN*/
struct cudaPitchedPtr
{
  void   *ptr;      ///< Pointer to allocated memory
  size_t  pitch;    ///< Pitch of allocated memory in bytes
  size_t  xsize;    ///< Logical width of allocation in elements
  size_t  ysize;    ///< Logical height of allocation in elements
};

/**
 * CUDA extent
 * \sa ::make_cudaExtent
 */
/*DEVICE_BUILTIN*/
struct cudaExtent
{
  size_t width;     ///< Width in bytes
  size_t height;    ///< Height in elements
  size_t depth;     ///< Depth in elements
};

/**
 * CUDA 3D position
 * \sa ::make_cudaPos
 */
/*DEVICE_BUILTIN*/
struct cudaPos
{
  size_t x;     ///< x
  size_t y;     ///< y
  size_t z;     ///< z
};

/**
 * CUDA 3D memory copying parameters
 */
/*DEVICE_BUILTIN*/
struct cudaMemcpy3DParms
{
  struct cudaArray      *srcArray;  ///< Source memory address
  struct cudaPos         srcPos;    ///< Source position offset
  struct cudaPitchedPtr  srcPtr;    ///< Pitched source memory address

  struct cudaArray      *dstArray;  ///< Destination memory address
  struct cudaPos         dstPos;    ///< Destination position offset
  struct cudaPitchedPtr  dstPtr;    ///< Pitched destination memory address

  struct cudaExtent      extent;    ///< Requested memory copy size
  enum cudaMemcpyKind    kind;      ///< Type of transfer
};

/**
 * CUDA graphics interop resource
 */
/*DEVICE_BUILTIN*/
struct cudaGraphicsResource; 

/**
 * CUDA graphics interop register flags
 */
/*DEVICE_BUILTIN*/ 
enum cudaGraphicsRegisterFlags
{
  cudaGraphicsRegisterFlagsNone  = 0   ///< Default
};

/**
 * CUDA graphics interop map flags
 */
/*DEVICE_BUILTIN*/
enum cudaGraphicsMapFlags
{
  cudaGraphicsMapFlagsNone         = 0,  ///< Default; Assume resource can be read/written
  cudaGraphicsMapFlagsReadOnly     = 1,  ///< CUDA will not write to this resource
  cudaGraphicsMapFlagsWriteDiscard = 2   ///< CUDA will only write to and will not read from this resource
};

/**
 * CUDA graphics interop array indices for cube maps
 */
/*DEVICE_BUILTIN*/
enum cudaGraphicsCubeFace {
  cudaGraphicsCubeFacePositiveX = 0x00, ///< Positive X face of cubemap
  cudaGraphicsCubeFaceNegativeX = 0x01, ///< Negative X face of cubemap
  cudaGraphicsCubeFacePositiveY = 0x02, ///< Positive Y face of cubemap
  cudaGraphicsCubeFaceNegativeY = 0x03, ///< Negative Y face of cubemap
  cudaGraphicsCubeFacePositiveZ = 0x04, ///< Positive Z face of cubemap
  cudaGraphicsCubeFaceNegativeZ = 0x05  ///< Negative Z face of cubemap
};

/**
 * CUDA function attributes
 */
/*DEVICE_BUILTIN*/
struct cudaFuncAttributes
{
   size_t sharedSizeBytes;  ///< Size of shared memory in bytes
   size_t constSizeBytes;   ///< Size of constant memory in bytes
   size_t localSizeBytes;   ///< Size of local memory in bytes
   int maxThreadsPerBlock;  ///< Maximum number of threads per block
   int numRegs;             ///< Number of registers used
   /** \brief PTX virtual architecture version for which the function was
    *  compiled. This value is the major PTX version * 10 + the minor PTX
    *  version, so a PTX version 1.3 function would return the value 13.
    *  For device emulation kernels, this is set to 9999.
    */
   int ptxVersion;
   /** \brief Binary architecture version for which the function was compiled.
    *  This value is the major binary version * 10 + the minor binary version,
    *  so a binary version 1.3 function would return the value 13.
    *  For device emulation kernels, this is set to 9999.
    */
   int binaryVersion;
   int __cudaReserved[6];
};

/**
 * CUDA function cache configurations
 */
/*DEVICE_BUILTIN*/
enum cudaFuncCache
{
  cudaFuncCachePreferNone   = 0,    ///< Default function cache configuration, no preference
  cudaFuncCachePreferShared = 1,    ///< Prefer larger shared memory and smaller L1 cache 
  cudaFuncCachePreferL1     = 2     ///< Prefer larger L1 cache and smaller shared memory
};

/**
 * CUDA device compute modes
 */
/*DEVICE_BUILTIN*/
enum cudaComputeMode
{
  cudaComputeModeDefault    =   0,  ///< Default compute mode (Multiple threads can use ::cudaSetDevice() with this device)
  cudaComputeModeExclusive  =   1,  ///< Compute-exclusive mode (Only one thread will be able to use ::cudaSetDevice() with this device)
  cudaComputeModeProhibited =   2   ///< Compute-prohibited mode (No threads can use ::cudaSetDevice() with this device)
};

/**
 * CUDA Limits
 */
/*DEVICE_BUILTIN*/
enum cudaLimit
{
    cudaLimitStackSize      = 0x00, ///< GPU thread stack size
    cudaLimitPrintfFifoSize = 0x01  ///< GPU printf FIFO size
};

/**
 * CUDA device properties
 */
/*DEVICE_BUILTIN*/
struct cudaDeviceProp
{
  char   name[256];                 ///< ASCII string identifying device
  size_t totalGlobalMem;            ///< Global memory available on device in bytes
  size_t sharedMemPerBlock;         ///< Shared memory available per block in bytes
  int    regsPerBlock;              ///< 32-bit registers available per block
  int    warpSize;                  ///< Warp size in threads
  size_t memPitch;                  ///< Maximum pitch in bytes allowed by memory copies
  int    maxThreadsPerBlock;        ///< Maximum number of threads per block
  int    maxThreadsDim[3];          ///< Maximum size of each dimension of a block
  int    maxGridSize[3];            ///< Maximum size of each dimension of a grid
  int    clockRate;                 ///< Clock frequency in kilohertz
  size_t totalConstMem;             ///< Constant memory available on device in bytes
  int    major;                     ///< Major compute capability
  int    minor;                     ///< Minor compute capability
  size_t textureAlignment;          ///< Alignment requirement for textures
  int    deviceOverlap;             ///< Device can concurrently copy memory and execute a kernel
  int    multiProcessorCount;       ///< Number of multiprocessors on device
  int    kernelExecTimeoutEnabled;  ///< Specified whether there is a run time limit on kernels
  int    integrated;                ///< Device is integrated as opposed to discrete
  int    canMapHostMemory;          ///< Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer
  int    computeMode;               ///< Compute mode (See ::cudaComputeMode)
  int    maxTexture1D;              ///< Maximum 1D texture size
  int    maxTexture2D[2];           ///< Maximum 2D texture dimensions
  int    maxTexture3D[3];           ///< Maximum 3D texture dimensions
  int    maxTexture2DArray[3];      ///< Maximum 2D texture array dimensions
  size_t surfaceAlignment;          ///< Alignment requirements for surfaces
  int    concurrentKernels;         ///< Device can possibly execute multiple kernels concurrently
  int    ECCEnabled;                ///< Device has ECC support enabled
  int    pciBusID;                  ///< PCI bus ID of the device
  int    pciDeviceID;               ///< PCI device ID of the device
  int    __cudaReserved[22];
};
































/*******************************************************************************
*                                                                              *
*  SHORTHAND TYPE DEFINITION USED BY RUNTIME API                               *
*                                                                              *
*******************************************************************************/

/**
 * CUDA Error types
 */
/*DEVICE_BUILTIN*/
typedef enum cudaError cudaError_t;

/**
 * CUDA stream
 */
/*DEVICE_BUILTIN*/
typedef struct CUstream_st *cudaStream_t;

/**
 * CUDA event types
 */
/*DEVICE_BUILTIN*/
typedef struct CUevent_st *cudaEvent_t;

/**
 * CUDA UUID types
 */
/*DEVICE_BUILTIN*/
typedef struct CUuuid_st cudaUUID_t;

/** @} */
/** @} */ /* END CUDART_TYPES */

#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 46 "c:\\cuda\\include\\surface_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
enum cudaSurfaceBoundaryMode
{
  cudaBoundaryModeZero = 0,
  cudaBoundaryModeClamp = 1,
  cudaBoundaryModeTrap = 2
};

/*DEVICE_BUILTIN*/
enum cudaSurfaceFormatMode
{
  cudaFormatModeForced,
  cudaFormatModeAuto
};

/*DEVICE_BUILTIN*/
struct surfaceReference
{
  struct cudaChannelFormatDesc channelDesc;
};

#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 46 "c:\\cuda\\include\\texture_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
enum cudaTextureAddressMode
{
  cudaAddressModeWrap,
  cudaAddressModeClamp,
  cudaAddressModeMirror
};

/*DEVICE_BUILTIN*/
enum cudaTextureFilterMode
{
  cudaFilterModePoint,
  cudaFilterModeLinear
};

/*DEVICE_BUILTIN*/
enum cudaTextureReadMode
{
  cudaReadModeElementType,
  cudaReadModeNormalizedFloat
};

/*DEVICE_BUILTIN*/
struct textureReference
{
  int                          normalized;
  enum cudaTextureFilterMode   filterMode;
  enum cudaTextureAddressMode  addressMode[3];
  struct cudaChannelFormatDesc channelDesc;
  int                          __cudaReserved[16];
};

#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 46 "c:\\cuda\\include\\vector_types.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */








#line 44 "c:\\cuda\\include\\host_defines.h"




















#line 65 "c:\\cuda\\include\\host_defines.h"










#line 76 "c:\\cuda\\include\\host_defines.h"
























#line 101 "c:\\cuda\\include\\host_defines.h"










#line 112 "c:\\cuda\\include\\host_defines.h"






#line 119 "c:\\cuda\\include\\host_defines.h"




#line 124 "c:\\cuda\\include\\host_defines.h"










#line 136 "c:\\cuda\\include\\host_defines.h"












#line 149 "c:\\cuda\\include\\host_defines.h"
#line 47 "c:\\cuda\\include\\vector_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/











#line 66 "c:\\cuda\\include\\vector_types.h"






#line 73 "c:\\cuda\\include\\vector_types.h"

/*DEVICE_BUILTIN*/
struct char1
{
  signed char x;
};

/*DEVICE_BUILTIN*/
struct uchar1 
{
  unsigned char x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(2)) char2
{
  signed char x, y;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(2)) uchar2
{
  unsigned char x, y;
};

/*DEVICE_BUILTIN*/
struct char3
{
  signed char x, y, z;
};

/*DEVICE_BUILTIN*/
struct uchar3
{
  unsigned char x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(4)) char4
{
  signed char x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(4)) uchar4
{
  unsigned char x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct short1
{
  short x;
};

/*DEVICE_BUILTIN*/
struct ushort1
{
  unsigned short x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(4)) short2
{
  short x, y;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(4)) ushort2
{
  unsigned short x, y;
};

/*DEVICE_BUILTIN*/
struct short3
{
  short x, y, z;
};

/*DEVICE_BUILTIN*/
struct ushort3
{
  unsigned short x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) short4 { short x; short y; short z; short w; };

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

/*DEVICE_BUILTIN*/
struct int1
{
  int x;
};

/*DEVICE_BUILTIN*/
struct uint1
{
  unsigned int x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) int2 { int x; int y; };

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) uint2 { unsigned int x; unsigned int y; };

/*DEVICE_BUILTIN*/
struct int3
{
  int x, y, z;
};

/*DEVICE_BUILTIN*/
struct uint3
{
  unsigned int x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) int4
{
  int x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) uint4
{
  unsigned int x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct long1
{
  long int x;
};

/*DEVICE_BUILTIN*/
struct ulong1
{
  unsigned long x;
};



/*DEVICE_BUILTIN*/
struct __declspec(align(8)) long2 { long int x; long int y; };

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) ulong2 { unsigned long int x; unsigned long int y; };















#line 241 "c:\\cuda\\include\\vector_types.h"

/*DEVICE_BUILTIN*/
struct long3
{
  long int x, y, z;
};

/*DEVICE_BUILTIN*/
struct ulong3
{
  unsigned long int x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) long4
{
  long int x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) ulong4
{
  unsigned long int x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct float1
{
  float x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(8)) float2 { float x; float y; };

/*DEVICE_BUILTIN*/
struct float3
{
  float x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) float4
{
  float x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct longlong1
{
  long long int x;
};

/*DEVICE_BUILTIN*/
struct ulonglong1
{
  unsigned long long int x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) longlong2
{
  long long int x, y;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) ulonglong2
{
  unsigned long long int x, y;
};

/*DEVICE_BUILTIN*/
struct longlong3
{
  long long int x, y, z;
};

/*DEVICE_BUILTIN*/
struct ulonglong3
{
  unsigned long long int x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) longlong4
{
  long long int x, y, z ,w;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) ulonglong4
{
  unsigned long long int x, y, z, w;
};

/*DEVICE_BUILTIN*/
struct double1
{
  double x;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) double2
{
  double x, y;
};

/*DEVICE_BUILTIN*/
struct double3
{
  double x, y, z;
};

/*DEVICE_BUILTIN*/
struct __declspec(align(16)) double4
{
  double x, y, z, w;
};

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
typedef struct char1 char1;
/*DEVICE_BUILTIN*/
typedef struct uchar1 uchar1;
/*DEVICE_BUILTIN*/
typedef struct char2 char2;
/*DEVICE_BUILTIN*/
typedef struct uchar2 uchar2;
/*DEVICE_BUILTIN*/
typedef struct char3 char3;
/*DEVICE_BUILTIN*/
typedef struct uchar3 uchar3;
/*DEVICE_BUILTIN*/
typedef struct char4 char4;
/*DEVICE_BUILTIN*/
typedef struct uchar4 uchar4;
/*DEVICE_BUILTIN*/
typedef struct short1 short1;
/*DEVICE_BUILTIN*/
typedef struct ushort1 ushort1;
/*DEVICE_BUILTIN*/
typedef struct short2 short2;
/*DEVICE_BUILTIN*/
typedef struct ushort2 ushort2;
/*DEVICE_BUILTIN*/
typedef struct short3 short3;
/*DEVICE_BUILTIN*/
typedef struct ushort3 ushort3;
/*DEVICE_BUILTIN*/
typedef struct short4 short4;
/*DEVICE_BUILTIN*/
typedef struct ushort4 ushort4;
/*DEVICE_BUILTIN*/
typedef struct int1 int1;
/*DEVICE_BUILTIN*/
typedef struct uint1 uint1;
/*DEVICE_BUILTIN*/
typedef struct int2 int2;
/*DEVICE_BUILTIN*/
typedef struct uint2 uint2;
/*DEVICE_BUILTIN*/
typedef struct int3 int3;
/*DEVICE_BUILTIN*/
typedef struct uint3 uint3;
/*DEVICE_BUILTIN*/
typedef struct int4 int4;
/*DEVICE_BUILTIN*/
typedef struct uint4 uint4;
/*DEVICE_BUILTIN*/
typedef struct long1 long1;
/*DEVICE_BUILTIN*/
typedef struct ulong1 ulong1;
/*DEVICE_BUILTIN*/
typedef struct long2 long2;
/*DEVICE_BUILTIN*/
typedef struct ulong2 ulong2;
/*DEVICE_BUILTIN*/
typedef struct long3 long3;
/*DEVICE_BUILTIN*/
typedef struct ulong3 ulong3;
/*DEVICE_BUILTIN*/
typedef struct long4 long4;
/*DEVICE_BUILTIN*/
typedef struct ulong4 ulong4;
/*DEVICE_BUILTIN*/
typedef struct float1 float1;
/*DEVICE_BUILTIN*/
typedef struct float2 float2;
/*DEVICE_BUILTIN*/
typedef struct float3 float3;
/*DEVICE_BUILTIN*/
typedef struct float4 float4;
/*DEVICE_BUILTIN*/
typedef struct longlong1 longlong1;
/*DEVICE_BUILTIN*/
typedef struct ulonglong1 ulonglong1;
/*DEVICE_BUILTIN*/
typedef struct longlong2 longlong2;
/*DEVICE_BUILTIN*/
typedef struct ulonglong2 ulonglong2;
/*DEVICE_BUILTIN*/
typedef struct longlong3 longlong3;
/*DEVICE_BUILTIN*/
typedef struct ulonglong3 ulonglong3;
/*DEVICE_BUILTIN*/
typedef struct longlong4 longlong4;
/*DEVICE_BUILTIN*/
typedef struct ulonglong4 ulonglong4;
/*DEVICE_BUILTIN*/
typedef struct double1 double1;
/*DEVICE_BUILTIN*/
typedef struct double2 double2;
/*DEVICE_BUILTIN*/
typedef struct double3 double3;
/*DEVICE_BUILTIN*/
typedef struct double4 double4;

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
struct dim3
{
    unsigned int x, y, z;

    __declspec(__host__) __declspec(__device__) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __declspec(__host__) __declspec(__device__) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __declspec(__host__) __declspec(__device__) operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }
#line 477 "c:\\cuda\\include\\vector_types.h"
};

/*DEVICE_BUILTIN*/
typedef struct dim3 dim3;



#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 54 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\channel_descriptor.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 48 "c:\\cuda\\include\\channel_descriptor.h"
#line 1 "c:\\cuda\\include\\cuda_runtime_api.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
* CUDA Runtime API Version 3.1                                                 *
*                                                                              *
*******************************************************************************/



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 54 "c:\\cuda\\include\\cuda_runtime_api.h"
#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 55 "c:\\cuda\\include\\cuda_runtime_api.h"

/** \cond impl_private */











#line 69 "c:\\cuda\\include\\cuda_runtime_api.h"

#line 71 "c:\\cuda\\include\\cuda_runtime_api.h"
/** \endcond impl_private */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/


extern "C" {
#line 82 "c:\\cuda\\include\\cuda_runtime_api.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
extern __declspec(__host__) cudaError_t __stdcall cudaMalloc3DArray(struct cudaArray** arrayPtr, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3D(const struct cudaMemcpy3DParms *p);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaMalloc(void **devPtr, size_t size);
extern __declspec(__host__) cudaError_t __stdcall cudaMallocHost(void **ptr, size_t size);
extern __declspec(__host__) cudaError_t __stdcall cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);
extern __declspec(__host__) cudaError_t __stdcall cudaMallocArray(struct cudaArray **array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaFree(void *devPtr);
extern __declspec(__host__) cudaError_t __stdcall cudaFreeHost(void *ptr);
extern __declspec(__host__) cudaError_t __stdcall cudaFreeArray(struct cudaArray *array);

extern __declspec(__host__) cudaError_t __stdcall cudaHostAlloc(void **pHost, size_t bytes, unsigned int flags);
extern __declspec(__host__) cudaError_t __stdcall cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);
extern __declspec(__host__) cudaError_t __stdcall cudaHostGetFlags(unsigned int *pFlags, void *pHost);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaMemGetInfo(size_t *free, size_t *total);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArray(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArray(void *dst, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyArrayToArray(struct cudaArray *dst, size_t wOffsetDst, size_t hOffsetDst, const struct cudaArray *src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArray(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArray(void *dst, size_t dpitch, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DArrayToArray(struct cudaArray *dst, size_t wOffsetDst, size_t hOffsetDst, const struct cudaArray *src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbol(const char *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbol(void *dst, const char *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToArrayAsync(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromArrayAsync(void *dst, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DToArrayAsync(struct cudaArray *dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, const struct cudaArray *src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyToSymbolAsync(const char *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void *dst, const char *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaMemset(void *devPtr, int value, size_t count);
extern __declspec(__host__) cudaError_t __stdcall cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolAddress(void **devPtr, const char *symbol);
extern __declspec(__host__) cudaError_t __stdcall cudaGetSymbolSize(size_t *size, const char *symbol);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaGetDeviceCount(int *count);
extern __declspec(__host__) cudaError_t __stdcall cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);
extern __declspec(__host__) cudaError_t __stdcall cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);
extern __declspec(__host__) cudaError_t __stdcall cudaSetDevice(int device);
extern __declspec(__host__) cudaError_t __stdcall cudaGetDevice(int *device);
extern __declspec(__host__) cudaError_t __stdcall cudaSetValidDevices(int *device_arr, int len);
extern __declspec(__host__) cudaError_t __stdcall cudaSetDeviceFlags( int flags );

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = 0xffffffff);
extern __declspec(__host__) cudaError_t __stdcall cudaBindTexture2D(size_t *offset,const struct textureReference *texref,const void *devPtr, const struct cudaChannelFormatDesc *desc,size_t width, size_t height, size_t pitch);
extern __declspec(__host__) cudaError_t __stdcall cudaBindTextureToArray(const struct textureReference *texref, const struct cudaArray *array, const struct cudaChannelFormatDesc *desc);
extern __declspec(__host__) cudaError_t __stdcall cudaUnbindTexture(const struct textureReference *texref);
extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
extern __declspec(__host__) cudaError_t __stdcall cudaGetTextureReference(const struct textureReference **texref, const char *symbol);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaBindSurfaceToArray(const struct surfaceReference *surfref, const struct cudaArray *array, const struct cudaChannelFormatDesc *desc);
extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceAlignmentOffset(size_t *offset, const struct surfaceReference *surfref);
extern __declspec(__host__) cudaError_t __stdcall cudaGetSurfaceReference(const struct surfaceReference **surfref, const char *symbol);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, const struct cudaArray *array);
extern __declspec(__host__) struct cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaGetLastError(void);
extern __declspec(__host__) cudaError_t __stdcall cudaPeekAtLastError(void);
extern __declspec(__host__) const char* __stdcall cudaGetErrorString(cudaError_t error);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaSetupArgument(const void *arg, size_t size, size_t offset);
extern __declspec(__host__) cudaError_t __stdcall cudaFuncSetCacheConfig(const char *func, enum cudaFuncCache cacheConfig);
extern __declspec(__host__) cudaError_t __stdcall cudaLaunch(const char *entry);
extern __declspec(__host__) cudaError_t __stdcall cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const char *func);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaStreamCreate(cudaStream_t *pStream);
extern __declspec(__host__) cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream);
extern __declspec(__host__) cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream);
extern __declspec(__host__) cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaEventCreate(cudaEvent_t *event);
extern __declspec(__host__) cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t *event, int flags);
extern __declspec(__host__) cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaEventQuery(cudaEvent_t event);
extern __declspec(__host__) cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event);
extern __declspec(__host__) cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event);
extern __declspec(__host__) cudaError_t __stdcall cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForDevice(double *d);
extern __declspec(__host__) cudaError_t __stdcall cudaSetDoubleForHost(double *d);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaThreadExit(void);
extern __declspec(__host__) cudaError_t __stdcall cudaThreadSynchronize(void);
extern __declspec(__host__) cudaError_t __stdcall cudaThreadSetLimit(enum cudaLimit limit, size_t value);
extern __declspec(__host__) cudaError_t __stdcall cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaDriverGetVersion(int *driverVersion);
extern __declspec(__host__) cudaError_t __stdcall cudaRuntimeGetVersion(int *runtimeVersion);
extern __declspec(__host__) cudaError_t __stdcall cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);


/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnregisterResource(struct cudaGraphicsResource *resource);
extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(struct cudaGraphicsResource *resource, unsigned int flags); 
extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsMapResources(int count, struct cudaGraphicsResource **resources, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsUnmapResources(int count, struct cudaGraphicsResource **resources, cudaStream_t stream = 0);
extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, struct cudaGraphicsResource *resource);
extern __declspec(__host__) cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(struct cudaArray **arrayPtr, struct cudaGraphicsResource *resource, unsigned int arrayIndex, unsigned int mipLevel);


}
#line 304 "c:\\cuda\\include\\cuda_runtime_api.h"



#line 308 "c:\\cuda\\include\\cuda_runtime_api.h"
#line 49 "c:\\cuda\\include\\channel_descriptor.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 50 "c:\\cuda\\include\\channel_descriptor.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 51 "c:\\cuda\\include\\channel_descriptor.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \addtogroup CUDART_HIGHLEVEL
 *
 * @{
 */

/**
 * \brief \hl Returns a channel descriptor using the specified format
 *
 * Returns a channel descriptor with format \p f and number of bits of each
 * component \p x, \p y, \p z, and \p w.  The ::cudaChannelFormatDesc is
 * defined as:
 * \code
  struct cudaChannelFormatDesc {
    int x, y, z, w;
    enum cudaChannelFormatKind f;
  };
 * \endcode
 *
 * where ::cudaChannelFormatKind is one of ::cudaChannelFormatKindSigned,
 * ::cudaChannelFormatKindUnsigned, or ::cudaChannelFormatKindFloat.
 *
 * \return
 * Channel descriptor with format \p f
 *
 * \sa \ref ::cudaCreateChannelDesc(int,int,int,int,cudaChannelFormatKind) "cudaCreateChannelDesc (Low level)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (High level)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (High level, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (High level)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (High level)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (High level, inherited channel descriptor)",
 * \ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) "cudaUnbindTexture (High level)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode>&) "cudaGetTextureAlignmentOffset (High level)"
 */
template<class T> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;



#line 133 "c:\\cuda\\include\\channel_descriptor.h"
  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
#line 135 "c:\\cuda\\include\\channel_descriptor.h"
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}



template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned long>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long1>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong1>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long2>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong2>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<long4>(void)
{
  int e = (int)sizeof(long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<ulong4>(void)
{
  int e = (int)sizeof(unsigned long) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

#line 364 "c:\\cuda\\include\\channel_descriptor.h"

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline __declspec(__host__) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

#line 394 "c:\\cuda\\include\\channel_descriptor.h"

/** @} */
/** @} */ /* END CUDART_TEXTURE_HL */

#line 399 "c:\\cuda\\include\\channel_descriptor.h"
#line 55 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\cuda_runtime_api.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */
















































































































































































































































































#line 308 "c:\\cuda\\include\\cuda_runtime_api.h"
#line 56 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\driver_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 46 "c:\\cuda\\include\\driver_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 47 "c:\\cuda\\include\\driver_functions.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 48 "c:\\cuda\\include\\driver_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__host__) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
{
  struct cudaPitchedPtr s;

  s.ptr   = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}

static __inline __declspec(__host__) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}

static __inline __declspec(__host__) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
{
  struct cudaExtent e;

  e.width  = w;
  e.height = h;
  e.depth  = d;

  return e;
}

#line 90 "c:\\cuda\\include\\driver_functions.h"
#line 57 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 58 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\vector_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 46 "c:\\cuda\\include\\vector_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 47 "c:\\cuda\\include\\vector_functions.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 48 "c:\\cuda\\include\\vector_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__host__) __declspec(__device__) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short3 make_short3(short x,short y, short z)
{ 
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline __declspec(__host__) __declspec(__device__) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

#line 296 "c:\\cuda\\include\\vector_functions.h"
#line 59 "C:\\CUDA\\include\\cuda_runtime.h"



#line 1 "c:\\cuda\\include\\common_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/



#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\common_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 49 "c:\\cuda\\include\\common_functions.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/


#pragma once
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"


extern "C" {
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"




#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

/* Define NULL pointer value */








/* For backwards compatibility */


/* Function prototypes */


 void *  __cdecl _memccpy(   void * _Dst,   const void * _Src,   int _Val,   size_t _MaxCount);
  const void *  __cdecl memchr(    const void * _Buf ,   int _Val,   size_t _MaxCount);
  int     __cdecl _memicmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
  int     __cdecl _memicmp_l(   const void * _Buf1,    const void * _Buf2,   size_t _Size,    _locale_t _Locale);
         int     __cdecl memcmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
         void *  __cdecl memcpy(    void * _Dst,    const void * _Src,   size_t _Size);

 errno_t  __cdecl memcpy_s(    void * _Dst,   rsize_t _DstSize,    const void * _Src,   rsize_t _MaxCount);
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
        void *  __cdecl memset(    void * _Dst,   int _Val,   size_t _Size);


/* Non-ANSI names for compatibility */
  void * __cdecl memccpy(  void * _Dst,    const void * _Src,   int _Val,   size_t _Size);
   int __cdecl memicmp(   const void * _Buf1,    const void * _Buf2,   size_t _Size);
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  errno_t __cdecl _strset_s(    char * _Dst,   size_t _DstSize,   int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(    char (&_Dest)[_Size],   int _Value) { return _strset_s(_Dest, _Size, _Value); } }
  char * __cdecl _strset(  char *_Dest,  int _Value);

  errno_t __cdecl strcpy_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src);
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Dest)[_Size],    const char * _Source) { return strcpy_s(_Dest, _Size, _Source); } }
  char * __cdecl strcpy(  char *_Dest,  const char * _Source);

  errno_t __cdecl strcat_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src);
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(    char (&_Dest)[_Size],    const char * _Source) { return strcat_s(_Dest, _Size, _Source); } }
  char * __cdecl strcat(  char *_Dest,  const char * _Source);
         int     __cdecl strcmp(   const char * _Str1,    const char * _Str2);
         size_t  __cdecl strlen(   const char * _Str);
  size_t  __cdecl strnlen(   const char * _Str,   size_t _MaxCount);

 static __inline size_t  __cdecl strnlen_s(    const char * _Str,   size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  errno_t __cdecl memmove_s(    void * _Dst,   rsize_t _DstSize,    const void * _Src,   rsize_t _MaxCount);
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"



#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
  void *  __cdecl memmove(    void * _Dst,    const void * _Src,   size_t _Size);
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"




#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  char *  __cdecl _strdup(   const char * _Src);



#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  const char *  __cdecl strchr(   const char * _Str,   int _Val);
  int     __cdecl _stricmp(    const char * _Str1,     const char * _Str2);
  int     __cdecl _strcmpi(    const char * _Str1,     const char * _Str2);
  int     __cdecl _stricmp_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
  int     __cdecl strcoll(    const char * _Str1,     const  char * _Str2);
  int     __cdecl _strcoll_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
  int     __cdecl _stricoll(    const char * _Str1,     const char * _Str2);
  int     __cdecl _stricoll_l(    const char * _Str1,     const char * _Str2,    _locale_t _Locale);
  int     __cdecl _strncoll  (   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
  int     __cdecl _strncoll_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);
  int     __cdecl _strnicoll (   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
  int     __cdecl _strnicoll_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);
  size_t  __cdecl strcspn(    const char * _Str,     const char * _Control);
   char *  __cdecl _strerror(   const char * _ErrMsg);
  errno_t __cdecl _strerror_s(    char * _Buf,   size_t _SizeInBytes,    const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],    const char * _ErrorMessage) { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
   char *  __cdecl strerror(  int);

  errno_t __cdecl strerror_s(    char * _Buf,   size_t _SizeInBytes,   int _ErrNum);
#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
  errno_t __cdecl _strlwr_s(    char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(    char (&_String)[_Size]) { return _strlwr_s(_String, _Size); } }
  char * __cdecl _strlwr(  char *_String);
  errno_t __cdecl _strlwr_s_l(    char * _Str,   size_t _Size,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(    char (&_String)[_Size],    _locale_t _Locale) { return _strlwr_s_l(_String, _Size, _Locale); } }
  char * __cdecl _strlwr_l(    char *_String,    _locale_t _Locale);

  errno_t __cdecl strncat_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src,   rsize_t _MaxCount);
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(    char (&_Dest)[_Size],    const char * _Source,   size_t _Count) { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
/* prefast noise VSW 489802 */
  char * __cdecl strncat(    char *_Dest,    const char * _Source,   size_t _Count);
#pragma warning(pop)


#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
  int     __cdecl strncmp(   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
  int     __cdecl _strnicmp(   const char * _Str1,    const char * _Str2,   size_t _MaxCount);
  int     __cdecl _strnicmp_l(   const char * _Str1,    const char * _Str2,   size_t _MaxCount,    _locale_t _Locale);

  errno_t __cdecl strncpy_s(    char * _Dst,   rsize_t _SizeInBytes,    const char * _Src,   rsize_t _MaxCount);
#line 156 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size],    const char * _Source,   size_t _Count) { return strncpy_s(_Dest, _Size, _Source, _Count); } }
  char * __cdecl strncpy(   char *_Dest,    const char * _Source,   size_t _Count);
  errno_t __cdecl _strnset_s(    char * _Str,   size_t _SizeInBytes,   int _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(    char (&_Dest)[_Size],   int _Val,   size_t _Count) { return _strnset_s(_Dest, _Size, _Val, _Count); } }
  char * __cdecl _strnset(    char *_Dest,   int _Val,   size_t _Count);
  const char *  __cdecl strpbrk(   const char * _Str,    const char * _Control);
  const char *  __cdecl strrchr(   const char * _Str,   int _Ch);
 char *  __cdecl _strrev(    char * _Str);
  size_t  __cdecl strspn(   const char * _Str,    const char * _Control);
  const char *  __cdecl strstr(   const char * _Str,    const char * _SubStr);
   char *  __cdecl strtok(    char * _Str,    const char * _Delim);

  char *  __cdecl strtok_s(    char * _Str,    const char * _Delim,        char ** _Context);
#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
  errno_t __cdecl _strupr_s(    char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(    char (&_String)[_Size]) { return _strupr_s(_String, _Size); } }
  char * __cdecl _strupr(  char *_String);
  errno_t __cdecl _strupr_s_l(    char * _Str,   size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(    char (&_String)[_Size], _locale_t _Locale) { return _strupr_s_l(_String, _Size, _Locale); } }
  char * __cdecl _strupr_l(    char *_String,    _locale_t _Locale);
  size_t  __cdecl strxfrm (   char * _Dst,    const char * _Src,   size_t _MaxCount);
  size_t  __cdecl _strxfrm_l(   char * _Dst,    const char * _Src,   size_t _MaxCount,    _locale_t _Locale);


extern "C++" {


 inline char * __cdecl strchr(   char * _Str,   int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
 inline char * __cdecl strpbrk(   char * _Str,    const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
 inline char * __cdecl strrchr(   char * _Str,   int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
 inline char * __cdecl strstr(   char * _Str,    const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"


 inline void * __cdecl memchr(   void * _Pv,   int _C,   size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
}
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"






#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

   char * __cdecl strdup(   const char * _Src);



#line 212 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

/* prototypes for oldnames.lib functions */
   int __cdecl strcmpi(   const char * _Str1,    const char * _Str2);
   int __cdecl stricmp(   const char * _Str1,    const char * _Str2);
  char * __cdecl strlwr(    char * _Str);
   int __cdecl strnicmp(   const char * _Str1,    const char * _Str,   size_t _MaxCount);
  char * __cdecl strnset(    char * _Str,   int _Val,   size_t _MaxCount);
  char * __cdecl strrev(    char * _Str);
         char * __cdecl strset(    char * _Str,   int _Val);
  char * __cdecl strupr(    char * _Str);

#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"




/* wide function prototypes, also declared in wchar.h  */




#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  wchar_t * __cdecl _wcsdup(   const wchar_t * _Str);



#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"


  errno_t __cdecl wcscat_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src);
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(    wchar_t (&_Dest)[_Size],    const wchar_t * _Source) { return wcscat_s(_Dest, _Size, _Source); } }
  wchar_t * __cdecl wcscat(  wchar_t *_Dest,  const wchar_t * _Source);
  const wchar_t * __cdecl wcschr(   const wchar_t * _Str, wchar_t _Ch);
  int __cdecl wcscmp(   const wchar_t * _Str1,    const wchar_t * _Str2);

  errno_t __cdecl wcscpy_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src);
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size],    const wchar_t * _Source) { return wcscpy_s(_Dest, _Size, _Source); } }
  wchar_t * __cdecl wcscpy(  wchar_t *_Dest,  const wchar_t * _Source);
  size_t __cdecl wcscspn(   const wchar_t * _Str,    const wchar_t * _Control);
  size_t __cdecl wcslen(   const wchar_t * _Str);
  size_t __cdecl wcsnlen(   const wchar_t * _Src,   size_t _MaxCount);

 static __inline size_t __cdecl wcsnlen_s(   const wchar_t * _Src,   size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

  errno_t __cdecl wcsncat_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src,   rsize_t _MaxCount);
#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(    wchar_t (&_Dest)[_Size],    const wchar_t * _Source,   size_t _Count) { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
  wchar_t * __cdecl wcsncat(    wchar_t *_Dest,    const wchar_t * _Source,   size_t _Count);
#pragma warning(pop)
  int __cdecl wcsncmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);

  errno_t __cdecl wcsncpy_s(    wchar_t * _Dst,   rsize_t _SizeInWords,    const wchar_t * _Src,   rsize_t _MaxCount);
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size],    const wchar_t * _Source,   size_t _Count) { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
  wchar_t * __cdecl wcsncpy(   wchar_t *_Dest,    const wchar_t * _Source,   size_t _Count);
  const wchar_t * __cdecl wcspbrk(   const wchar_t * _Str,    const wchar_t * _Control);
  const wchar_t * __cdecl wcsrchr(   const wchar_t * _Str,   wchar_t _Ch);
  size_t __cdecl wcsspn(   const wchar_t * _Str,    const wchar_t * _Control);
  const wchar_t * __cdecl wcsstr(   const wchar_t * _Str,    const wchar_t * _SubStr);
   wchar_t * __cdecl wcstok(    wchar_t * _Str,    const wchar_t * _Delim);

  wchar_t * __cdecl wcstok_s(    wchar_t * _Str,    const wchar_t * _Delim,        wchar_t ** _Context);
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
   wchar_t * __cdecl _wcserror(  int _ErrNum);
  errno_t __cdecl _wcserror_s(    wchar_t * _Buf,   size_t _SizeInWords,   int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) { return _wcserror_s(_Buffer, _Size, _Error); } }
   wchar_t * __cdecl __wcserror(   const wchar_t * _Str);
  errno_t __cdecl __wcserror_s(    wchar_t * _Buffer,   size_t _SizeInWords,    const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],    const wchar_t * _ErrorMessage) { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  int __cdecl _wcsicmp(   const wchar_t * _Str1,    const wchar_t * _Str2);
  int __cdecl _wcsicmp_l(   const wchar_t * _Str1,    const wchar_t * _Str2,    _locale_t _Locale);
  int __cdecl _wcsnicmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
  int __cdecl _wcsnicmp_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);
  errno_t __cdecl _wcsnset_s(    wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(    wchar_t (&_Dst)[_Size], wchar_t _Val,   size_t _MaxCount) { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
  wchar_t * __cdecl _wcsnset(    wchar_t *_Str, wchar_t _Val,   size_t _MaxCount);
 wchar_t * __cdecl _wcsrev(    wchar_t * _Str);
  errno_t __cdecl _wcsset_s(    wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(    wchar_t (&_Str)[_Size], wchar_t _Val) { return _wcsset_s(_Str, _Size, _Val); } }
  wchar_t * __cdecl _wcsset(    wchar_t *_Str, wchar_t _Val);

  errno_t __cdecl _wcslwr_s(    wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(    wchar_t (&_String)[_Size]) { return _wcslwr_s(_String, _Size); } }
  wchar_t * __cdecl _wcslwr(  wchar_t *_String);
  errno_t __cdecl _wcslwr_s_l(    wchar_t * _Str,   size_t _SizeInWords,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(    wchar_t (&_String)[_Size],    _locale_t _Locale) { return _wcslwr_s_l(_String, _Size, _Locale); } }
  wchar_t * __cdecl _wcslwr_l(    wchar_t *_String,    _locale_t _Locale);
  errno_t __cdecl _wcsupr_s(    wchar_t * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(    wchar_t (&_String)[_Size]) { return _wcsupr_s(_String, _Size); } }
  wchar_t * __cdecl _wcsupr(  wchar_t *_String);
  errno_t __cdecl _wcsupr_s_l(    wchar_t * _Str,   size_t _Size,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(    wchar_t (&_String)[_Size],    _locale_t _Locale) { return _wcsupr_s_l(_String, _Size, _Locale); } }
  wchar_t * __cdecl _wcsupr_l(    wchar_t *_String,    _locale_t _Locale);
  size_t __cdecl wcsxfrm(   wchar_t * _Dst,    const wchar_t * _Src,   size_t _MaxCount);
  size_t __cdecl _wcsxfrm_l(   wchar_t * _Dst,    const wchar_t *_Src,   size_t _MaxCount,    _locale_t _Locale);
  int __cdecl wcscoll(   const wchar_t * _Str1,    const wchar_t * _Str2);
  int __cdecl _wcscoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,    _locale_t _Locale);
  int __cdecl _wcsicoll(   const wchar_t * _Str1,    const wchar_t * _Str2);
  int __cdecl _wcsicoll_l(   const wchar_t * _Str1,    const wchar_t *_Str2,    _locale_t _Locale);
  int __cdecl _wcsncoll(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
  int __cdecl _wcsncoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);
  int __cdecl _wcsnicoll(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
  int __cdecl _wcsnicoll_l(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount,    _locale_t _Locale);




extern "C++" {
 inline wchar_t * __cdecl wcschr(   wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
 inline wchar_t * __cdecl wcspbrk(   wchar_t *_Str,    const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
 inline wchar_t * __cdecl wcsrchr(   wchar_t *_Str,   wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
 inline wchar_t * __cdecl wcsstr(   wchar_t *_Str,    const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
#line 341 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"






#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

   wchar_t * __cdecl wcsdup(   const wchar_t * _Str);



#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

/* old names */


/* prototypes for oldnames.lib functions */
   int __cdecl wcsicmp(   const wchar_t * _Str1,    const wchar_t * _Str2);
   int __cdecl wcsnicmp(   const wchar_t * _Str1,    const wchar_t * _Str2,   size_t _MaxCount);
  wchar_t * __cdecl wcsnset(    wchar_t * _Str,   wchar_t _Val,   size_t _MaxCount);
  wchar_t * __cdecl wcsrev(    wchar_t * _Str);
  wchar_t * __cdecl wcsset(    wchar_t * _Str, wchar_t _Val);
  wchar_t * __cdecl wcslwr(    wchar_t * _Str);
  wchar_t * __cdecl wcsupr(    wchar_t * _Str);
   int __cdecl wcsicoll(   const wchar_t * _Str1,    const wchar_t * _Str2);

#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"


#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"



}
#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"

#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\string.h"
#line 51 "c:\\cuda\\include\\common_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/


#pragma once
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"



#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"



/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


extern "C" {
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"








#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"

/* Define _CRTIMP */










/* Define __cdecl for non-Microsoft compilers */



#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


























typedef long clock_t;

#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"










/* Define NULL pointer value */










struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };

#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


/* Clock ticks macro - ANSI version */




/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
   int* __cdecl __daylight(void);


/* offset for Daylight Saving Time */
   long* __cdecl __dstbias(void);


/* difference in seconds between GMT and local time */
   long* __cdecl __timezone(void);


/* standard/daylight savings time zone names */
    char ** __cdecl __tzname(void);


 errno_t __cdecl _get_daylight(  int * _Daylight);
 errno_t __cdecl _get_dstbias(  long * _Daylight_savings_bias);
 errno_t __cdecl _get_timezone(  long * _Timezone);
 errno_t __cdecl _get_tzname(  size_t *_ReturnValue,     char *_Buffer,   size_t _SizeInBytes,   int _Index);


/* Function prototypes */
   char * __cdecl asctime(  const struct tm * _Tm);

  errno_t __cdecl asctime_s(    char *_Buf,   size_t _SizeInBytes,   const struct tm * _Tm);
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   const struct tm * _Time) { return asctime_s(_Buffer, _Size, _Time); } }

  char * __cdecl _ctime32(  const __time32_t * _Time);
 errno_t __cdecl _ctime32_s(    char *_Buf,   size_t _SizeInBytes,   const __time32_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   const __time32_t * _Time) { return _ctime32_s(_Buffer, _Size, _Time); } }

  clock_t __cdecl clock(void);
 double __cdecl _difftime32(  __time32_t _Time1,   __time32_t _Time2);

   struct tm * __cdecl _gmtime32(  const __time32_t * _Time);
  errno_t __cdecl _gmtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

  struct tm * __cdecl _localtime32(  const __time32_t * _Time);
 errno_t __cdecl _localtime32_s(  struct tm *_Tm,   const __time32_t * _Time);

 size_t __cdecl strftime(    char * _Buf,   size_t _SizeInBytes,     const char * _Format,   const struct tm * _Tm);
 size_t __cdecl _strftime_l(   char *_Buf,   size_t _Max_size,     const char * _Format,   const struct tm *_Tm,    _locale_t _Locale);

  errno_t __cdecl _strdate_s(    char *_Buf,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) { return _strdate_s(_Buffer, _Size); } }
  char * __cdecl _strdate(  char *_Buffer);

  errno_t __cdecl _strtime_s(    char *_Buf ,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) { return _strtime_s(_Buffer, _Size); } }
  char * __cdecl _strtime(  char *_Buffer);

 __time32_t __cdecl _time32(  __time32_t * _Time);
 __time32_t __cdecl _mktime32(   struct tm * _Tm);
 __time32_t __cdecl _mkgmtime32(   struct tm * _Tm);




 void __cdecl _tzset(void);
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"

  double __cdecl _difftime64(  __time64_t _Time1,   __time64_t _Time2);
  char * __cdecl _ctime64(  const __time64_t * _Time);
 errno_t __cdecl _ctime64_s(    char *_Buf,   size_t _SizeInBytes,   const __time64_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size],   const __time64_t * _Time) { return _ctime64_s(_Buffer, _Size, _Time); } }

  struct tm * __cdecl _gmtime64(  const __time64_t * _Time);
 errno_t __cdecl _gmtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

  struct tm * __cdecl _localtime64(  const __time64_t * _Time);
 errno_t __cdecl _localtime64_s(  struct tm *_Tm,   const __time64_t *_Time);

 __time64_t __cdecl _mktime64(   struct tm * _Tm);
 __time64_t __cdecl _mkgmtime64(   struct tm * _Tm);
 __time64_t __cdecl _time64(  __time64_t * _Time);

/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetLocalTime" " instead. See online help for details.")) unsigned __cdecl _getsystime(  struct tm * _Tm);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetLocalTime" " instead. See online help for details.")) unsigned __cdecl _setsystime(  struct tm * _Tm, unsigned _MilliSec);









/* wide function prototypes, also declared in wchar.h */
 
  wchar_t * __cdecl _wasctime(  const struct tm * _Tm);
 errno_t __cdecl _wasctime_s(    wchar_t *_Buf,   size_t _SizeInWords,   const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   const struct tm * _Time) { return _wasctime_s(_Buffer, _Size, _Time); } }

  wchar_t * __cdecl _wctime32(  const __time32_t *_Time);
 errno_t __cdecl _wctime32_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   const __time32_t * _Time) { return _wctime32_s(_Buffer, _Size, _Time); } }

 size_t __cdecl wcsftime(    wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t * _Format,    const struct tm * _Tm);
 size_t __cdecl _wcsftime_l(    wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t *_Format,   const struct tm *_Tm,    _locale_t _Locale);

 errno_t __cdecl _wstrdate_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) { return _wstrdate_s(_Buffer, _Size); } }
  wchar_t * __cdecl _wstrdate(  wchar_t *_Buffer);

 errno_t __cdecl _wstrtime_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) { return _wstrtime_s(_Buffer, _Size); } }
  wchar_t * __cdecl _wstrtime(  wchar_t *_Buffer);

  wchar_t * __cdecl _wctime64(  const __time64_t * _Time);
 errno_t __cdecl _wctime64_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   const __time64_t * _Time) { return _wctime64_s(_Buffer, _Size, _Time); } }


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"
/***
*wtime.inl - inline definitions for wctime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of wctime().
*
*       [Public]
*
****/


#pragma once
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"







#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"

#pragma warning(pop)

#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\wtime.inl"
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
/***
*time.inl - inline definitions for time-related functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the time-related function definitions.
*
*       [Public]
*
****/


#pragma once
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"







#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"




























































static __inline double __cdecl difftime(time_t _Time1, time_t _Time2)
{
    return _difftime64(_Time1,_Time2);
}
 static __inline char * __cdecl ctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _ctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t * _Time)
{
    return _ctime64_s(_Buffer, _SizeInBytes, _Time);
}
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl gmtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _gmtime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl gmtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _gmtime64_s(_Tm, _Time);
}
#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
 static __inline struct tm * __cdecl localtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _localtime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl localtime_s(struct tm * _Tm, const time_t * _Time)
{
    return _localtime64_s(_Tm, _Time);
}
static __inline time_t __cdecl mktime(struct tm * _Tm)
{
    return _mktime64(_Tm);
}
static __inline time_t __cdecl _mkgmtime(struct tm * _Tm)
{
    return _mkgmtime64(_Tm);
}
static __inline time_t __cdecl time(time_t * _Time)
{
    return _time64(_Time);
}
#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"


#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.inl"
#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"



/* Non-ANSI names for compatibility */



/*
daylight, timezone, and tzname are not available under /clr:pure.
Please use _daylight, _timezone, and _tzname or 
_get_daylight, _get_timezone, and _get_tzname instead.
*/

  extern int daylight;
  extern long timezone;
  extern char * tzname[2];
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"

  void __cdecl tzset(void);

#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"



}
#line 292 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"


#pragma pack(pop)
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"

#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\time.h"
#line 52 "c:\\cuda\\include\\common_functions.h"

extern "C"
{

/*DEVICE_BUILTIN*/
extern  __declspec(__host__) __declspec(__device__) clock_t __cdecl clock(void) ;
/*DEVICE_BUILTIN*/
extern         __declspec(__host__) __declspec(__device__) void*   __cdecl memset(void*, int, size_t) ;
/*DEVICE_BUILTIN*/
extern         __declspec(__host__) __declspec(__device__) void*   __cdecl memcpy(void*, const void*, size_t) ;

}













#line 78 "c:\\cuda\\include\\common_functions.h"

#line 80 "c:\\cuda\\include\\common_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\math_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 54 "c:\\cuda\\include\\math_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 55 "c:\\cuda\\include\\math_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern "C"
{

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int            __cdecl abs(int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long int       __cdecl labs(long int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llabs(long long int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl fabs(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fabsf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    min(int, int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) unsigned int           umin(unsigned int, unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llmin(long long int, long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) unsigned long long int ullmin(unsigned long long int, unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fminf(float, float) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 fmin(double, double) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    max(int, int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) unsigned int           umax(unsigned int, unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llmax(long long int, long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) unsigned long long int ullmax(unsigned long long int, unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fmaxf(float, float) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 fmax(double, double) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl sin(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  sinf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl cos(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  cosf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) void                   sincos(double, double*, double*) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) void                   sincosf(float, float*, float*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl tan(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  tanf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl sqrt(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  sqrtf(float) ;         

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 rsqrt(double);                
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  rsqrtf(float);                

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 exp2(double) ;         
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  exp2f(float) ;         

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 exp10(double) ;        
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  exp10f(float) ;        

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 expm1(double) ;        
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  expm1f(float) ;        

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 log2(double) ;         
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  log2f(float) ;         

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl log10(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  log10f(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl log(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  logf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 log1p(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  log1pf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl floor(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  floorf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl exp(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  expf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl cosh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                 coshf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl sinh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  sinhf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl tanh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  tanhf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 acosh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  acoshf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 asinh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  asinhf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 atanh(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  atanhf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl ldexp(double, int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  ldexpf(float, int) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 logb(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  logbf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    ilogb(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    ilogbf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 scalbn(double, int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  scalbnf(float, int) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 scalbln(double, long int) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  scalblnf(float, long int) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl frexp(double, int*) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  frexpf(float, int*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 round(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  roundf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long int               lround(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long int               lroundf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llround(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llroundf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 rint(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  rintf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long int               lrint(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long int               lrintf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llrint(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) long long int          llrintf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 nearbyint(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  nearbyintf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl ceil(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  ceilf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 trunc(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  truncf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 fdim(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fdimf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl atan2(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  atan2f(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl atan(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  atanf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl asin(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  asinf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl acos(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  acosf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl hypot(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  hypotf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 cbrt(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  cbrtf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 rcbrt(double);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  rcbrtf(float);

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 sinpi(double);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  sinpif(float);

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl pow(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  powf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl modf(double, double*) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  modff(float, float*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double         __cdecl fmod(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fmodf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 remainder(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  remainderf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 remquo(double, double, int*) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  remquof(float, float, int*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 erf(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  erff(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 erfinv(double);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  erfinvf(float);

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 erfc(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  erfcf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 erfcinv(double);
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  erfcinvf(float);

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 lgamma(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  lgammaf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 tgamma(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  tgammaf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 copysign(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  copysignf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 nextafter(double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  nextafterf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 nan(const char*) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  nanf(const char*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __isinf(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __isinff(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __isnan(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __isnanf(float) ;










#line 417 "c:\\cuda\\include\\math_functions.h"

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __finite(double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __finitef(float) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __signbit(double) ;

#line 426 "c:\\cuda\\include\\math_functions.h"

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) int                    __signbitf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) double                 fma(double, double, double) ;
/*DEVICE_BUILTIN*/
extern __declspec(__host__) __declspec(__device__) float                  fmaf(float, float, float) ;


/* these are here to avoid warnings on the call graph.
   long double is not supported on the device */





















#line 460 "c:\\cuda\\include\\math_functions.h"

}

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


extern "C" {
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"



/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */


struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;


#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */


struct _complex {
        double x,y; /* real and imaginary parts */
        } ;




#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


/* Constant definitions for the exception type passed in the _exception struct
 */












/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */


 extern double _HUGE;


#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"



/* Function prototypes */




        int     __cdecl abs(  int _X);
        long    __cdecl labs(  long _X);
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

        double  __cdecl acos(  double _X);
        double  __cdecl asin(  double _X);
        double  __cdecl atan(  double _X);
        double  __cdecl atan2(  double _Y,   double _X);

  double __cdecl _copysign (  double _Number,   double _Sign);
  double __cdecl _chgsign (  double _X);

#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
        double  __cdecl cos(  double _X);
        double  __cdecl cosh(  double _X);
        double  __cdecl exp(  double _X);
 double  __cdecl fabs(  double _X);
        double  __cdecl fmod(  double _X,   double _Y);
        double  __cdecl log(  double _X);
        double  __cdecl log10(  double _X);
        double  __cdecl pow(  double _X,   double _Y);
        double  __cdecl sin(  double _X);
        double  __cdecl sinh(  double _X);
        double  __cdecl tan(  double _X);
        double  __cdecl tanh(  double _X);
        double  __cdecl sqrt(  double _X);


  double  __cdecl atof(   const char *_String);
  double  __cdecl _atof_l(   const char *_String,    _locale_t _Locale);
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

 double  __cdecl _cabs(  struct _complex _Complex_value);
 double  __cdecl ceil(  double _X);
 double  __cdecl floor(  double _X);
 double  __cdecl frexp(  double _X,   int * _Y);
 double  __cdecl _hypot(  double _X,   double _Y);
 double  __cdecl _j0(  double _X );
 double  __cdecl _j1(  double _X );
 double  __cdecl _jn(int _X,   double _Y);
 double  __cdecl ldexp(  double _X,   int _Y);




#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
        int     __cdecl _matherr(   struct _exception * _Except);
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
 double  __cdecl modf(  double _X,   double * _Y);

 double  __cdecl _y0(  double _X);
 double  __cdecl _y1(  double _X);
 double  __cdecl _yn(  int _X,   double _Y);







#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"







































#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"



/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

 float  __cdecl acosf(   float _X);
 float  __cdecl asinf(   float _X);
 float  __cdecl atanf(   float _X);
 float  __cdecl atan2f(   float  _Y,   float  _X);
 float  __cdecl cosf(   float _X);
 float  __cdecl sinf(   float _X);
 float  __cdecl tanf(   float _X);

/* 4.5.3 Hyperbolic functions */
 float  __cdecl coshf(   float _X);
 float  __cdecl sinhf(   float _X);
 float  __cdecl tanhf(   float _X);

/* 4.5.4 Exponential and logarithmic functions */
 float  __cdecl expf(   float  _X);
 float  __cdecl logf(   float  _X);
 float  __cdecl log10f(   float  _X);
 float  __cdecl modff(   float  _X,   float*  _Y);

/* 4.5.5 Power functions */
 float  __cdecl powf(   float _X,   float _Y);
 float  __cdecl sqrtf(   float  _X);

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
 float  __cdecl ceilf(   float  _X);
 float  __cdecl floorf(   float  _X);
 float  __cdecl fmodf(   float  _X,   float _Y);

 float  __cdecl _hypotf(  float  _X,   float _Y);

 float __cdecl _copysignf (  float _Number,   float _Sign);
 float __cdecl _chgsignf (  float _X);
 float __cdecl _logbf(  float _X);
 float __cdecl _nextafterf(  float _X,   float _Y);
 int    __cdecl _finitef(  float _X);
 int    __cdecl _isnanf(  float _X);
 int    __cdecl _fpclassf(  float _X);

#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */





























































inline long double acosl(  long double _X)
        {return (acos((double)_X)); }
inline long double asinl(  long double _X)
        {return (asin((double)_X)); }
inline long double atanl(  long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(  long double _Y,   long double _X)
        {return (atan2((double)_Y, (double)_X)); }
inline long double ceill(  long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(  long double _X)
        {return (cos((double)_X)); }
inline long double coshl(  long double _X)
        {return (cosh((double)_X)); }
inline long double expl(  long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(  long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(  long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(  long double _X,   long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(  long double _X,   int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(  long double _X,   int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(  long double _X)
        {return (log((double)_X)); }
inline long double log10l(  long double _X)
        {return (log10((double)_X)); }
inline long double modfl(  long double _X,   long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(  long double _X,   long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(  long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(  long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(  long double _X)
        {return (sqrt((double)_X)); }

inline long double tanl(  long double _X)
        {return (tan((double)_X)); }


#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

inline long double tanhl(  long double _X)
        {return (tanh((double)_X)); }

inline long double _chgsignl(  long double _Number)
{
    return _chgsign(static_cast<double>(_Number)); 
}

inline long double _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}

inline float frexpf(  float _X,   int *_Y)
        {return ((float)frexp((double)_X, _Y)); }


inline float fabsf(  float _X)
        {return ((float)fabs((double)_X)); }
inline float ldexpf(  float _X,   int _Y)
        {return ((float)ldexp((double)_X, _Y)); }









































#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
#line 432 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"



/* Non-ANSI names for compatibility */













 extern double HUGE;


#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

  double  __cdecl cabs(  struct _complex _X);
  double  __cdecl hypot(  double _X,   double _Y);
  double  __cdecl j0(  double _X);
  double  __cdecl j1(  double _X);
  double  __cdecl jn(  int _X,   double _Y);
  double  __cdecl y0(  double _X);
  double  __cdecl y1(  double _X);
  double  __cdecl yn(  int _X,   double _Y);

#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline long __cdecl abs(  long _X)
        {return (labs(_X)); }
inline double __cdecl abs(  double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(  double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(  float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(  float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(  float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(  float _Y,   float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(  float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(  float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(  float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(  float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(  float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(  float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(  float _X,   float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(  float _X,   int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(  float _X,   int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(  float _X)
        {return (logf(_X)); }
inline float __cdecl log10(  float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(  float _X,   float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(  float _X,   float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(  float _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(  float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(  float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(  float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(  float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(  float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(  long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(  long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(  long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(  long double _Y,   long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(  long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(  long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(  long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(  long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(  long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(  long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(  long double _X,   long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(  long double _X,   int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(  long double _X,   int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(  long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(  long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(  long double _X,   long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(  long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(  long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(  long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(  long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(  long double _X)
        {return (tanhl(_X)); }

}
#line 590 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"


#pragma pack(pop)
#line 594 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

#line 596 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"







































#line 636 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

#line 464 "c:\\cuda\\include\\math_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/


#pragma once
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"



/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


extern "C" {
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* Define NULL pointer value */








/* Definition of the argument values for the exit() function */








typedef int (__cdecl * _onexit_t)(void);



#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"



#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


/* Non-ANSI name for compatibility */

#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


/* Data structure definitions for div and ldiv runtimes. */



typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;


#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/*
 * structs used to fool the compiler into not generating floating point
 * instructions when copying and pushing [long] double values
 */





#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 120 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;

/* push and pop long, which is #defined as __int64 by a spec2k test */



typedef struct {
        /*
         * Assume there is a long double type
         */
        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 150 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* Maximum value that can be returned by the rand function. */



/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */





#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

 extern int __mb_cur_max;



#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
 int __cdecl ___mb_cur_max_func(void);
 int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* Minimum and maximum macros */




/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */






/*
 * Argument values for _set_error_mode().
 */





/*
 * Argument values for _set_abort_behavior().
 */



/*
 * Sizes for buffers used by the getenv/putenv family of functions.
 */



/* a purecall handler procedure. Never returns normally */
typedef void (__cdecl *_purecall_handler)(void); 

/* establishes a purecall handler for the process */
 _purecall_handler __cdecl _set_purecall_handler(   _purecall_handler _Handler);
 _purecall_handler __cdecl _get_purecall_handler();
#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"







#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
}
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


/* a invalid_arg handler procedure. */
typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 

/* establishes a invalid_arg handler for the process */
 _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(   _invalid_parameter_handler _Handler);
 _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


extern "C++"
{




#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"






#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
}
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* External variable declarations */









 unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(  unsigned long _Value);
errno_t __cdecl _get_doserrno(  unsigned long * _Value);

/* you can't modify this, but it is non-const for backcompat */
  char ** __cdecl __sys_errlist(void);


  int * __cdecl __sys_nerr(void);













#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


 extern int __argc;          /* count of cmd line args */
 extern char ** __argv;      /* pointer to table of cmd line args */
 extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */







#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"





 extern char ** _environ;    /* pointer to environment table */
 extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  extern char * _pgmptr;      /* points to the module (EXE) name */
  extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */














#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(     char ** _Value);
errno_t __cdecl _get_wpgmptr(     wchar_t ** _Value);



  extern int _fmode;          /* default file translation mode */



#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

 errno_t __cdecl _set_fmode(  int _Mode);
 errno_t __cdecl _get_fmode(  int * _PMode);

/* _countof helper */



#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* function prototypes */



 __declspec(noreturn) void __cdecl exit(  int _Code);
 __declspec(noreturn) void __cdecl _exit(  int _Code);
 void __cdecl abort(void);
#line 375 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

 unsigned int __cdecl _set_abort_behavior(  unsigned int _Flags,   unsigned int _Mask);







        __int64    __cdecl _abs64(__int64);













#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"












#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"





   int    __cdecl atoi(   const char *_Str);
  int    __cdecl _atoi_l(   const char *_Str,    _locale_t _Locale);
  long   __cdecl atol(   const char *_Str);
  long   __cdecl _atol_l(   const char *_Str,    _locale_t _Locale);



  void * __cdecl bsearch_s(  const void * _Key,    const void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 430 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  void * __cdecl bsearch(  const void * _Key,    const void * _Base, 
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));


 void __cdecl qsort_s(   void * _Base, 
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 439 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
 void __cdecl qsort(   void * _Base, 
	  size_t _NumOfElements,   size_t _SizeOfElements, 
          int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
         unsigned short __cdecl _byteswap_ushort(  unsigned short _Short);
         unsigned long  __cdecl _byteswap_ulong (  unsigned long _Long);
         unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Int64);
  div_t  __cdecl div(  int _Numerator,   int _Denominator);
   char * __cdecl getenv(   const char * _VarName);

  errno_t __cdecl getenv_s(  size_t * _ReturnSize,     char * _DstBuf,   rsize_t _DstSize,    const char * _VarName);
#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t * _ReturnSize, char (&_Dest)[_Size],    const char * _VarName) { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  errno_t __cdecl _dupenv_s(    char **_PBuffer,   size_t * _PBufferSizeInBytes,    const char * _VarName);



#line 462 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  errno_t __cdecl _itoa_s(  int _Value,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(  int _Value, char (&_Dest)[_Size],   int _Radix) { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
  char * __cdecl _itoa( int _Value,   char *_Dest,  int _Radix);
  errno_t __cdecl _i64toa_s(  __int64 _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
  char * __cdecl _i64toa(  __int64 _Val,    char * _DstBuf,   int _Radix);
  errno_t __cdecl _ui64toa_s(  unsigned __int64 _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
  char * __cdecl _ui64toa(  unsigned __int64 _Val,    char * _DstBuf,   int _Radix);
  __int64 __cdecl _atoi64(   const char * _String);
  __int64 __cdecl _atoi64_l(   const char * _String,    _locale_t _Locale);
  __int64 __cdecl _strtoi64(   const char * _String,     char ** _EndPtr,   int _Radix);
  __int64 __cdecl _strtoi64_l(   const char * _String,     char ** _EndPtr,   int _Radix,    _locale_t _Locale);
  unsigned __int64 __cdecl _strtoui64(   const char * _String,     char ** _EndPtr,   int _Radix);
  unsigned __int64 __cdecl _strtoui64_l(   const char * _String,     char ** _EndPtr,   int  _Radix,    _locale_t _Locale);
  ldiv_t __cdecl ldiv(  long _Numerator,   long _Denominator);

extern "C++"
{
    inline ldiv_t  div(  long _A1,   long _A2)
    {
        return ldiv(_A1, _A2);
    }
}
#line 486 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  errno_t __cdecl _ltoa_s(  long _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Dest)[_Size],   int _Radix) { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
  char * __cdecl _ltoa( long _Value,   char *_Dest,  int _Radix);
  int    __cdecl mblen(     const char * _Ch,   size_t _MaxCount);
  int    __cdecl _mblen_l(     const char * _Ch,   size_t _MaxCount,    _locale_t _Locale);
  size_t __cdecl _mbstrlen(   const char * _Str);
  size_t __cdecl _mbstrlen_l(   const char *_Str,    _locale_t _Locale);
  size_t __cdecl _mbstrnlen(   const char *_Str,   size_t _MaxCount);
  size_t __cdecl _mbstrnlen_l(   const char *_Str,   size_t _MaxCount,    _locale_t _Locale);
 int    __cdecl mbtowc(   wchar_t * _DstCh,      const char * _SrcCh,   size_t _SrcSizeInBytes);
 int    __cdecl _mbtowc_l(   wchar_t * _DstCh,      const char * _SrcCh,   size_t _SrcSizeInBytes,    _locale_t _Locale);
  errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,     wchar_t * _DstBuf,   size_t _SizeInWords,      const char * _SrcBuf,   size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],    const char * _Source,   size_t _MaxCount) { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
  size_t __cdecl mbstowcs(  wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

  errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted,     wchar_t * _DstBuf,   size_t _SizeInWords,      const char * _SrcBuf,   size_t _MaxCount,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size],    const char * _Source,   size_t _MaxCount,    _locale_t _Locale) { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
  size_t __cdecl _mbstowcs_l(    wchar_t *_Dest,    const char * _Source,   size_t _MaxCount,    _locale_t _Locale);

  int    __cdecl rand(void);


#line 509 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  int    __cdecl _set_error_mode(  int _Mode);

 void   __cdecl srand(  unsigned int _Seed);
  double __cdecl strtod(   const char * _Str,     char ** _EndPtr);
  double __cdecl _strtod_l(   const char * _Str,     char ** _EndPtr,    _locale_t _Locale);
  long   __cdecl strtol(   const char * _Str,     char ** _EndPtr,   int _Radix );
  long   __cdecl _strtol_l(   const char *_Str,     char **_EndPtr,   int _Radix,    _locale_t _Locale);
  unsigned long __cdecl strtoul(   const char * _Str,     char ** _EndPtr,   int _Radix);
  unsigned long __cdecl _strtoul_l(const char * _Str,     char **_EndPtr,   int _Radix,    _locale_t _Locale);


 int __cdecl system(   const char * _Command);
#line 523 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  errno_t __cdecl _ultoa_s(  unsigned long _Val,     char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Dest)[_Size],   int _Radix) { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
  char * __cdecl _ultoa( unsigned long _Value,   char *_Dest,  int _Radix);
  int    __cdecl wctomb(    char * _MbCh,   wchar_t _WCh);
  int    __cdecl _wctomb_l(   char * _MbCh,   wchar_t _WCh,    _locale_t _Locale);

  errno_t __cdecl wctomb_s(  int * _SizeConverted,     char * _MbCh,   rsize_t _SizeInBytes,   wchar_t _WCh);
#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  errno_t __cdecl _wctomb_s_l(  int * _SizeConverted,     char * _MbCh,   size_t _SizeInBytes,   wchar_t _WCh,    _locale_t _Locale);
  errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,     char * _Dst,   size_t _DstSizeInBytes,    const wchar_t * _Src,   size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],    const wchar_t * _Source,   size_t _MaxCount) { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
  size_t __cdecl wcstombs(  char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
  errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,     char * _Dst,   size_t _DstSizeInBytes,    const wchar_t * _Src,   size_t _MaxCountInBytes,    _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],    const wchar_t * _Source,   size_t _MaxCount,    _locale_t _Locale) { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
  size_t __cdecl _wcstombs_l(    char *_Dest,    const wchar_t * _Source,   size_t _MaxCount,    _locale_t _Locale);

























#line 564 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


































#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
    __declspec(noalias) __declspec(restrict)    void * __cdecl calloc(  size_t _NumOfElements,   size_t _SizeOfElements);
                     __declspec(noalias)                                                                             void   __cdecl free(   void * _Memory);
    __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc(  size_t _Size);
   __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc(   void * _Memory,   size_t _NewSize);
   __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc(   void * _Memory,   size_t _Count,   size_t _Size);
                     __declspec(noalias)                                                                             void   __cdecl _aligned_free(   void * _Memory);
   __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc(  size_t _Size,   size_t _Alignment);
   __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc(  size_t _Size,   size_t _Alignment,   size_t _Offset);
   __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc(   void * _Memory,   size_t _NewSize,   size_t _Alignment);
   __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc(   void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment);
   __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc(   void * _Memory,   size_t _NewSize,   size_t _Alignment,   size_t _Offset);
   __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc(   void * _Memory,   size_t _Count,   size_t _Size,   size_t _Alignment,   size_t _Offset);
                                                   size_t __cdecl _aligned_msize(  void * _Memory,   size_t _Alignment,   size_t _Offset);


















#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

#line 633 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"



/* wide function prototypes, also declared in wchar.h  */

  errno_t __cdecl _itow_s (  int _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Dest)[_Size],   int _Radix) { return _itow_s(_Value, _Dest, _Size, _Radix); } }
  wchar_t * __cdecl _itow( int _Value,   wchar_t *_Dest,  int _Radix);
  errno_t __cdecl _ltow_s (  long _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Dest)[_Size],   int _Radix) { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
  wchar_t * __cdecl _ltow( long _Value,   wchar_t *_Dest,  int _Radix);
  errno_t __cdecl _ultow_s (  unsigned long _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Dest)[_Size],   int _Radix) { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
  wchar_t * __cdecl _ultow( unsigned long _Value,   wchar_t *_Dest,  int _Radix);
  double __cdecl wcstod(   const wchar_t * _Str,     wchar_t ** _EndPtr);
  double __cdecl _wcstod_l(   const wchar_t *_Str,     wchar_t ** _EndPtr,    _locale_t _Locale);
  long   __cdecl wcstol(   const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  long   __cdecl _wcstol_l(   const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,    _locale_t _Locale);
  unsigned long __cdecl wcstoul(   const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  unsigned long __cdecl _wcstoul_l(   const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,    _locale_t _Locale);
   wchar_t * __cdecl _wgetenv(   const wchar_t * _VarName);
  errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize,     wchar_t * _DstBuf,   size_t _DstSizeInWords,    const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize, wchar_t (&_Dest)[_Size],    const wchar_t * _VarName) { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  errno_t __cdecl _wdupenv_s(    wchar_t **_Buffer,   size_t *_BufferSizeInWords,    const wchar_t *_VarName);



#line 667 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"



 int __cdecl _wsystem(   const wchar_t * _Command);
#line 672 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  double __cdecl _wtof(   const wchar_t *_Str);
  double __cdecl _wtof_l(   const wchar_t *_Str,    _locale_t _Locale);
  int __cdecl _wtoi(   const wchar_t *_Str);
  int __cdecl _wtoi_l(   const wchar_t *_Str,    _locale_t _Locale);
  long __cdecl _wtol(   const wchar_t *_Str);
  long __cdecl _wtol_l(   const wchar_t *_Str,    _locale_t _Locale);

  errno_t __cdecl _i64tow_s(  __int64 _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
  wchar_t * __cdecl _i64tow(  __int64 _Val,    wchar_t * _DstBuf,   int _Radix);
  errno_t __cdecl _ui64tow_s(  unsigned __int64 _Val,     wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
  wchar_t * __cdecl _ui64tow(  unsigned __int64 _Val,    wchar_t * _DstBuf,   int _Radix);
  __int64   __cdecl _wtoi64(   const wchar_t *_Str);
  __int64   __cdecl _wtoi64_l(   const wchar_t *_Str,    _locale_t _Locale);
  __int64   __cdecl _wcstoi64(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __int64   __cdecl _wcstoi64_l(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix,    _locale_t _Locale);
  unsigned __int64  __cdecl _wcstoui64(   const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  unsigned __int64  __cdecl _wcstoui64_l(   const wchar_t *_Str ,     wchar_t ** _EndPtr,   int _Radix,    _locale_t _Locale);


#line 692 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"




/* 
Buffer size required to be passed to _gcvt, fcvt and other fp conversion routines
*/







#line 707 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  char * __cdecl _fullpath(    char * _FullPath,    const char * _Path,   size_t _SizeInBytes);





#line 715 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  errno_t __cdecl _ecvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDights,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
   char * __cdecl _ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
  errno_t __cdecl _fcvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
   char * __cdecl _fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
 errno_t __cdecl _gcvt_s(    char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits) { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
  char * __cdecl _gcvt(  double _Val,   int _NumOfDigits,    char * _DstBuf);

  int __cdecl _atodbl(  _CRT_DOUBLE * _Result,    char * _Str);
  int __cdecl _atoldbl(  _LDOUBLE * _Result,    char * _Str);
  int __cdecl _atoflt(  _CRT_FLOAT * _Result,    char * _Str);
  int __cdecl _atodbl_l(  _CRT_DOUBLE * _Result,    char * _Str,    _locale_t _Locale);
  int __cdecl _atoldbl_l(  _LDOUBLE * _Result,    char * _Str,    _locale_t _Locale);
  int __cdecl _atoflt_l(  _CRT_FLOAT * _Result,    char * _Str,    _locale_t _Locale);
         unsigned long __cdecl _lrotl(  unsigned long _Val,   int _Shift);
         unsigned long __cdecl _lrotr(  unsigned long _Val,   int _Shift);
  errno_t   __cdecl _makepath_s(    char * _PathResult,   size_t _SizeInWords,    const char * _Drive,    const char * _Dir,    const char * _Filename,
           const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size],    const char * _Drive,    const char * _Dir,    const char * _Filename,    const char * _Ext) { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
  void __cdecl _makepath(  char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 751 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"












#line 764 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(   _onexit_t _Func);
#line 766 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
        


 void __cdecl perror(   const char * _ErrMsg);
#line 771 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

#pragma warning (push)
#pragma warning (disable:6540) 
  int    __cdecl _putenv(   const char * _EnvString);
  errno_t __cdecl _putenv_s(   const char * _Name,    const char * _Value);
         unsigned int __cdecl _rotl(  unsigned int _Val,   int _Shift);
         unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Val,   int _Shift);
         unsigned int __cdecl _rotr(  unsigned int _Val,   int _Shift);
         unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Val,   int _Shift);
#pragma warning (pop)

 errno_t __cdecl _searchenv_s(   const char * _Filename,    const char * _EnvVar,     char * _ResultPath,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(   const char * _Filename,    const char * _EnvVar, char (&_ResultPath)[_Size]) { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
  void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,   char *_ResultPath);

  void   __cdecl _splitpath(   const char * _FullPath,    char * _Drive,    char * _Dir,    char * _Filename,    char * _Ext);
  errno_t  __cdecl _splitpath_s(   const char * _FullPath, 
		    char * _Drive,   size_t _DriveSize, 
		    char * _Dir,   size_t _DirSize, 
		    char * _Filename,   size_t _FilenameSize, 
		    char * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(  const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

 void   __cdecl _swab(     char * _Buf1,      char * _Buf2, int _SizeInBytes);



/* wide function prototypes, also declared in wchar.h  */




#line 804 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  wchar_t * __cdecl _wfullpath(    wchar_t * _FullPath,    const wchar_t * _Path,   size_t _SizeInWords);



#line 810 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

  errno_t __cdecl _wmakepath_s(    wchar_t * _PathResult,   size_t _SIZE,    const wchar_t * _Drive,    const wchar_t * _Dir,    const wchar_t * _Filename,
           const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size],    const wchar_t * _Drive,    const wchar_t * _Dir,    const wchar_t * _Filename,    const wchar_t * _Ext) { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
  void __cdecl _wmakepath(  wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);


 void __cdecl _wperror(   const wchar_t * _ErrMsg);
#line 819 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"
  int    __cdecl _wputenv(   const wchar_t * _EnvString);
  errno_t __cdecl _wputenv_s(   const wchar_t * _Name,    const wchar_t * _Value);
 errno_t __cdecl _wsearchenv_s(   const wchar_t * _Filename,    const wchar_t * _EnvVar,     wchar_t * _ResultPath,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(   const wchar_t * _Filename,    const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
  void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,   wchar_t *_ResultPath);
  void   __cdecl _wsplitpath(   const wchar_t * _FullPath,    wchar_t * _Drive,    wchar_t * _Dir,    wchar_t * _Filename,    wchar_t * _Ext);
 errno_t __cdecl _wsplitpath_s(   const wchar_t * _FullPath, 
		    wchar_t * _Drive,   size_t _DriveSize, 
		    wchar_t * _Dir,   size_t _DirSize, 
		    wchar_t * _Filename,   size_t _FilenameSize, 
		    wchar_t * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(  const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 834 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details."))  void __cdecl _seterrormode(  int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details."))  void __cdecl _beep(  unsigned _Frequency,   unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details."))  void __cdecl _sleep(  unsigned long _Duration);

#line 841 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"





/* Non-ANSI names for compatibility */










#pragma warning(push)
#pragma warning(disable: 4141)  
    char * __cdecl ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
    char * __cdecl fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
 		 char * __cdecl gcvt(  double _Val,   int _NumOfDigits,    char * _DstBuf);
 		 char * __cdecl itoa(  int _Val,    char * _DstBuf,   int _Radix);
 		 char * __cdecl ltoa(  long _Val,    char * _DstBuf,   int _Radix);
   int    __cdecl putenv(   const char * _EnvString);
										 void   __cdecl swab(    char * _Buf1,    char * _Buf2,   int _SizeInBytes);
 	 char * __cdecl ultoa(  unsigned long _Val,    char * _Dstbuf,   int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(   _onexit_t _Func);

#line 871 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

#line 873 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


}

#line 878 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"


#pragma pack(pop)
#line 882 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

#line 884 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdlib.h"

#line 465 "c:\\cuda\\include\\math_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"
// cmath standard header
#pragma once


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
/* yvals.h values header for Microsoft C/C++ */
#pragma once



#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


#pragma pack(push,8)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"



 
  
 #line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Checked Iterators".
*/






























#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

		/* NAMING PROPERTIES */


		/* THREAD AND LOCALE CONTROL */




		/* THREAD-LOCAL STORAGE */

 
  

 

#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 
  
 #line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 
  
 #line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


 
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


 
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


 
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"



#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


	

#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
		
	#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"







#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* _SECURE_CRT definitions */







/* _SECURE_SCL switches: default values */



#line 130 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* See note on use of deprecate at the top of this file */


#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"




#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"



#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* _SECURE_SCL switches: helper macros */
/* See note on use of deprecate at the top of this file */








#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"








#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/*
 * Assert in debug builds.
 * set errno and return
 *
 */
 









#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 #line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 




#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 
 

 #line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 









 









// validation a la Secure CRT
 









 

 









 









 




 





 
 

 
















#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* _SECURE_VALIDATION is the name of the bool template argument used to define iterators
   with secure validation selectively turned on or off (for an example, see the std::list
   iterators). Notice that all the _SCL_SECURE_TRAITS_* validation macros are almost identical
   to the _SCL_SECURE_* macros defined above. The only difference is the:
        
        if (_SECURE_VALIDATION) { }

   statement, which will statically evaluate to true or false. With optimizations on, the
   compiler will optimize the check away.
 */
 

 

 

 










 










 










 










 









#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"











#line 369 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#pragma once































































































#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"



#pragma comment(lib,"libcpmt")
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"
#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"

#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"

#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"

#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\use_ansi.h"
#line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


 
#line 375 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"




#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* Define _CRTIMP2 */
 










/* Define _CRTIMP2_NCEEPURE */
 
  

#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
   
  #line 400 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
 #line 401 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"





/* Define _MRTIMP2 */
 










/* Define _MRTIMP2_NPURE */
 

   


#line 425 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
    
   #line 427 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 #line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* Define _MRTIMP2_NCEE */
 
  

#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
   
  #line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
 #line 438 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* Define _MRTIMP2_NCEEPURE */
 
  

#line 444 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
   
  #line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
 #line 447 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

/* Define _MRTIMP2_NPURE_NCEEPURE */
 
  

#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
   
  #line 455 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
 #line 456 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 

#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 
   


     
   #line 467 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
 #line 468 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


    
#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


  



		/* NAMESPACE */

 
  
  
  

/*
We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard
*/
  
  
  

  





/* #define _GLOBAL_USING	*.h in global namespace, c* imports to std */

   
   
   
  #line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

  
  
  
  

 












#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

 

 
namespace std {
typedef bool _Bool;
}
 #line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

		/* VC++ COMPILER PARAMETERS */





		/* INTEGER PROPERTIES */






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		/* STDIO PROPERTIES */


 
  
 #line 555 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"





		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */






 
namespace std {
		// CLASS _Lockit

// warning 4412 is benign here
#pragma warning(push)
#pragma warning(disable:4412)
class  _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  

    













#line 595 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
    explicit __thiscall _Lockit();	// set default lock
	explicit __thiscall _Lockit(int);	// set the lock
	__thiscall ~_Lockit();	// clear the lock
    #line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

	 _Lockit(const _Lockit&);				// not defined
	_Lockit&  operator=(const _Lockit&);	// not defined

	int _Locktype;

  












#line 627 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

	};



























































































#line 721 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

class  _Mutex
	{	// lock under program control
public:

  
    
    
















#line 746 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
    __thiscall _Mutex();
	__thiscall ~_Mutex();
	void __thiscall _Lock();
	void __thiscall _Unlock();
    #line 751 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Mutex_ctor(_Mutex *);
    static  void __cdecl _Mutex_dtor(_Mutex *);
    static  void __cdecl _Mutex_Lock(_Mutex *);
    static  void __cdecl _Mutex_Unlock(_Mutex *);

	 _Mutex(const _Mutex&);				// not defined
	_Mutex&  operator=(const _Mutex&);	// not defined
	void *_Mtx;

  







#line 771 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

	};

class  _Init_locks
	{	// initialize mutexes
public:

 
    
    








#line 790 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks();
    #line 793 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 807 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

	};
#pragma warning(pop)
}
 #line 812 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"





		/* MISCELLANEOUS MACROS AND TYPES */

 void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;






  
  
 #pragma pack(pop)
#line 832 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"

#line 834 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\yvals.h"


/*
 * Copyright (c) 1992-2008 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.05:0009 */
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"









 #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/













































































































































































































































































































































































































































































































































































































































#line 636 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\math.h"

#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"


 
namespace std {
using ::acosf; using ::asinf;
using ::atanf; using ::atan2f; using ::ceilf;
using ::cosf; using ::coshf; using ::expf;
using ::fabsf; using ::floorf; using ::fmodf;
using ::frexpf; using ::ldexpf; using ::logf;
using ::log10f; using ::modff; using ::powf;
using ::sinf; using ::sinhf; using ::sqrtf;
using ::tanf; using ::tanhf;

using ::acosl; using ::asinl;
using ::atanl; using ::atan2l; using ::ceill;
using ::cosl; using ::coshl; using ::expl;
using ::fabsl; using ::floorl; using ::fmodl;
using ::frexpl; using ::ldexpl; using ::logl;
using ::log10l; using ::modfl; using ::powl;
using ::sinl; using ::sinhl; using ::sqrtl;
using ::tanl; using ::tanhl;

using ::abs;

using ::acos; using ::asin;
using ::atan; using ::atan2; using ::ceil;
using ::cos; using ::cosh; using ::exp;
using ::fabs; using ::floor; using ::fmod;
using ::frexp; using ::ldexp; using ::log;
using ::log10; using ::modf; using ::pow;
using ::sin; using ::sinh; using ::sqrt;
using ::tan; using ::tanh;


}
 #line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"

#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cmath"


/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
#line 466 "c:\\cuda\\include\\math_functions.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"
// cstdlib standard header
#pragma once










 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"


 

namespace std {

using ::size_t; using ::div_t; using ::ldiv_t;

using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;


}
 #line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"

#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\cstdlib"

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
#line 467 "c:\\cuda\\include\\math_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/



























































#line 533 "c:\\cuda\\include\\math_functions.h"

static __inline __declspec(__host__) __declspec(__device__) long long int abs(long long int a)
{
  return llabs(a);
}

static __inline __declspec(__host__) __declspec(__device__) int signbit(double a)
{
  return __signbit(a);
}

static __inline __declspec(__host__) __declspec(__device__) int signbit(float a)
{
  return __signbitf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isinf(double a)
{
  return __isinf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isinf(float a)
{
  return __isinff(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isnan(double a)
{
  return __isnan(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isnan(float a)
{
  return __isnanf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isfinite(double a)
{
  return __finite(a);
}

static __inline __declspec(__host__) __declspec(__device__) int isfinite(float a)
{
  return __finitef(a);
}

template<class T> extern __declspec(__host__) __declspec(__device__) T _Pow_int(T, int);

#line 582 "c:\\cuda\\include\\math_functions.h"



#line 586 "c:\\cuda\\include\\math_functions.h"

extern __declspec(__host__) __declspec(__device__) long int __cdecl abs(long int);
extern __declspec(__host__) __declspec(__device__) float    __cdecl abs(float);
extern __declspec(__host__) __declspec(__device__) double   __cdecl abs(double);
extern __declspec(__host__) __declspec(__device__) float    __cdecl fabs(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl ceil(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl floor(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl sqrt(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl pow(float, float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl pow(float, int);
extern __declspec(__host__) __declspec(__device__) double   __cdecl pow(double, int);
extern __declspec(__host__) __declspec(__device__) float    __cdecl log(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl log10(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl fmod(float, float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl modf(float, float*);
extern __declspec(__host__) __declspec(__device__) float    __cdecl exp(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl frexp(float, int*);
extern __declspec(__host__) __declspec(__device__) float    __cdecl ldexp(float, int);
extern __declspec(__host__) __declspec(__device__) float    __cdecl asin(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl sin(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl sinh(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl acos(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl cos(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl cosh(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl atan(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl atan2(float, float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl tan(float);
extern __declspec(__host__) __declspec(__device__) float    __cdecl tanh(float);



#line 618 "c:\\cuda\\include\\math_functions.h"

static __inline __declspec(__host__) __declspec(__device__) float logb(float a)
{
  return logbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) int ilogb(float a)
{
  return ilogbf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbn(float a, int b)
{
  return scalbnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float scalbln(float a, long int b)
{
  return scalblnf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float exp2(float a)
{
  return exp2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float exp10(float a)
{
  return exp10f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float expm1(float a)
{
  return expm1f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log2(float a)
{
  return log2f(a);
}

static __inline __declspec(__host__) __declspec(__device__) float log1p(float a)
{
  return log1pf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rsqrt(float a)
{
  return rsqrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float acosh(float a)
{
  return acoshf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float asinh(float a)
{
  return asinhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float atanh(float a)
{
  return atanhf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float hypot(float a, float b)
{
  return hypotf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float cbrt(float a)
{
  return cbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rcbrt(float a)
{
  return rcbrtf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float sinpi(float a)
{
  return sinpif(a);
}

static __inline __declspec(__host__) __declspec(__device__) void sincos(float a, float *sptr, float *cptr)
{
  sincosf(a, sptr, cptr);
}

static __inline __declspec(__host__) __declspec(__device__) float erf(float a)
{
  return erff(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfinv(float a)
{
  return erfinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfc(float a)
{
  return erfcf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float erfcinv(float a)
{
  return erfcinvf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float lgamma(float a)
{
  return lgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float tgamma(float a)
{
  return tgammaf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, float b)
{
  return copysignf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double copysign(double a, float b)
{
  return copysign(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) float copysign(float a, double b)
{
  return copysignf(a, (float)b);
}

static __inline __declspec(__host__) __declspec(__device__) float nextafter(float a, float b)
{
  return nextafterf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remainder(float a, float b)
{
  return remainderf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float remquo(float a, float b, int *quo)
{
  return remquof(a, b, quo);
}

static __inline __declspec(__host__) __declspec(__device__) float round(float a)
{
  return roundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lround(float a)
{
  return lroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llround(float a)
{
  return llroundf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float trunc(float a)
{
  return truncf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float rint(float a)
{
  return rintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long int lrint(float a)
{
  return lrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) long long int llrint(float a)
{
  return llrintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float nearbyint(float a)
{
  return nearbyintf(a);
}

static __inline __declspec(__host__) __declspec(__device__) float fdim(float a, float b)
{
  return fdimf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fma(float a, float b, float c)
{
  return fmaf(a, b, c);
}

static __inline __declspec(__host__) __declspec(__device__) float fmax(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) float fmin(float a, float b)
{
  return fminf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(int a, unsigned int b)
{
  return umin((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int min(unsigned int a, int b)
{
  return umin(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int min(long long int a, long long int b)
{
  return llmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(long long int a, unsigned long long int b)
{
  return ullmin((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int min(unsigned long long int a, long long int b)
{
  return ullmin(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float min(float a, float b)
{
  return fminf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, double b)
{
  return fmin(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(float a, double b)
{
  return fmin((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double min(double a, float b)
{
  return fmin(a, (double)b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(int a, unsigned int b)
{
  return umax((unsigned int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned int max(unsigned int a, int b)
{
  return umax(a, (unsigned int)b);
}

static __inline __declspec(__host__) __declspec(__device__) long long int max(long long int a, long long int b)
{
  return llmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(long long int a, unsigned long long int b)
{
  return ullmax((unsigned long long int)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) unsigned long long int max(unsigned long long int a, long long int b)
{
  return ullmax(a, (unsigned long long int)b);
}

static __inline __declspec(__host__) __declspec(__device__) float max(float a, float b)
{
  return fmaxf(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, double b)
{
  return fmax(a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(float a, double b)
{
  return fmax((double)a, b);
}

static __inline __declspec(__host__) __declspec(__device__) double max(double a, float b)
{
  return fmax(a, (double)b);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 4987 "c:\\cuda\\include\\math_functions.h"





#line 4993 "c:\\cuda\\include\\math_functions.h"



#line 1 "c:\\cuda\\include\\math_functions_dbl_ptx1.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */













































































































































































































































































































































































#line 401 "c:\\cuda\\include\\math_functions_dbl_ptx1.h"

#line 403 "c:\\cuda\\include\\math_functions_dbl_ptx1.h"
#line 4997 "c:\\cuda\\include\\math_functions.h"

#line 4999 "c:\\cuda\\include\\math_functions.h"





#line 5005 "c:\\cuda\\include\\math_functions.h"

#line 5007 "c:\\cuda\\include\\math_functions.h"

#line 88 "c:\\cuda\\include\\common_functions.h"

#line 90 "c:\\cuda\\include\\common_functions.h"

#line 63 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\cuda_surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\cuda_surface_types.h"
#line 1 "c:\\cuda\\include\\channel_descriptor.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */











































































































































































































































































































































































#line 399 "c:\\cuda\\include\\channel_descriptor.h"
#line 49 "c:\\cuda\\include\\cuda_surface_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 50 "c:\\cuda\\include\\cuda_surface_types.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 51 "c:\\cuda\\include\\cuda_surface_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 52 "c:\\cuda\\include\\cuda_surface_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*SURFACE_TYPE*/
template<class T, int dim = 1>
struct surface : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __declspec(__host__) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }
};

/*SURFACE_TYPE*/
template<int dim>
struct surface<void, dim> : public surfaceReference
{
  __declspec(__host__) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }
};

#line 85 "c:\\cuda\\include\\cuda_surface_types.h"

#line 87 "c:\\cuda\\include\\cuda_surface_types.h"
#line 64 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\cuda_texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\cuda_texture_types.h"
#line 1 "c:\\cuda\\include\\channel_descriptor.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */











































































































































































































































































































































































#line 399 "c:\\cuda\\include\\channel_descriptor.h"
#line 49 "c:\\cuda\\include\\cuda_texture_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 50 "c:\\cuda\\include\\cuda_texture_types.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 51 "c:\\cuda\\include\\cuda_texture_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 52 "c:\\cuda\\include\\cuda_texture_types.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*TEXTURE_TYPE*/
template<class T, int dim = 1, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct texture : public textureReference
{
  __declspec(__host__) texture(int                         norm  = 0,
                   enum cudaTextureFilterMode  fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = cudaCreateChannelDesc<T>();
  }

  __declspec(__host__) texture(int                          norm,
                   enum cudaTextureFilterMode   fMode,
                   enum cudaTextureAddressMode  aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized     = norm;
    filterMode     = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc    = desc;
  }
};

#line 90 "c:\\cuda\\include\\cuda_texture_types.h"

#line 92 "c:\\cuda\\include\\cuda_texture_types.h"
#line 65 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\device_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/



#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 49 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 50 "c:\\cuda\\include\\device_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

extern "C"
{

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __mulhi(int, int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __umulhi(unsigned int, unsigned int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) long long int          __mul64hi(long long int, long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __umul64hi(unsigned long long int, unsigned long long int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __int_as_float(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __float_as_int(float);


/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __synchronous_start(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __synchronous_end(void);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __syncthreads(void);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __prof_trigger(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __threadfence(void);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __threadfence_block(void);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __trap(void);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __brkpt(int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __saturatef(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __sad(int, int, unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __usad(unsigned int, unsigned int, unsigned int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __mul24(int, int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __umul24(unsigned int, unsigned int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  fdividef(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fdividef(float, float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) double                 fdivide(double, double);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __sinf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __cosf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __tanf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) void                   __sincosf(float, float*, float*) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __expf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __exp10f(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __log2f(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __log10f(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __logf(float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __powf(float, float) ;

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __float2int_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __float2int_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __float2int_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __float2int_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __float2uint_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __float2uint_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __float2uint_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __float2uint_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __int2float_rn(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __int2float_rz(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __int2float_ru(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __int2float_rd(int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __uint2float_rn(unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __uint2float_rz(unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __uint2float_ru(unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __uint2float_rd(unsigned int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) long long int          __float2ll_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) long long int          __float2ll_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) long long int          __float2ll_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) long long int          __float2ll_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __float2ull_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __float2ull_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __float2ull_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __float2ull_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ll2float_rn(long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ll2float_rz(long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ll2float_ru(long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ll2float_rd(long long int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ull2float_rn(unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ull2float_rz(unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ull2float_ru(unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __ull2float_rd(unsigned long long int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned short         __float2half_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __half2float(unsigned short);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fadd_rn(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fadd_rz(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fadd_ru(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fadd_rd(float, float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmul_rn(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmul_rz(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmul_ru(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmul_rd(float, float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmaf_rn(float, float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmaf_rz(float, float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmaf_ru(float, float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fmaf_rd(float, float, float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __frcp_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __frcp_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __frcp_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __frcp_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fsqrt_rn(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fsqrt_rz(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fsqrt_ru(float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fsqrt_rd(float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fdiv_rn(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fdiv_rz(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fdiv_ru(float, float);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float                  __fdiv_rd(float, float);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __clz(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __ffs(int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __popc(unsigned int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __brev(unsigned int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __clzll(long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __ffsll(long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int                    __popcll(unsigned long long int);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned long long int __brevll(unsigned long long int);

/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int           __byte_perm(unsigned int, unsigned int, unsigned int);
























#line 320 "c:\\cuda\\include\\device_functions.h"

}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int mulhi(int a, int b)
{
  return __mulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, unsigned int b)
{
  return __umulhi(a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(int a, unsigned int b)
{
  return __umulhi((unsigned int)a, b);
}

static __inline __declspec(__device__) unsigned int mulhi(unsigned int a, int b)
{
  return __umulhi(a, (unsigned int)b);
}

static __inline __declspec(__device__) long long int mul64hi(long long int a, long long int b)
{
  return __mul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(long long int a, unsigned long long int b)
{
  return __umul64hi((unsigned long long int)a, b);
}

static __inline __declspec(__device__) unsigned long long int mul64hi(unsigned long long int a, long long int b)
{
  return __umul64hi(a, (unsigned long long int)b);
}

static __inline __declspec(__device__) int float_as_int(float a)
{
  return __float_as_int(a);
}

static __inline __declspec(__device__) float int_as_float(int a)
{
  return __int_as_float(a);
}

static __inline __declspec(__device__) float saturate(float a)
{
  return __saturatef(a);
}

static __inline __declspec(__device__) int mul24(int a, int b)
{
  return __mul24(a, b);
}

static __inline __declspec(__device__) unsigned int umul24(unsigned int a, unsigned int b)
{
  return __umul24(a, b);
}

static __inline __declspec(__device__) void trap(void)
{
  __trap();
}

static __inline __declspec(__device__) void brkpt(int c)
{
  __brkpt(c);
}

static __inline __declspec(__device__) void syncthreads(void)
{
  __syncthreads();
}

static __inline __declspec(__device__) void prof_trigger(int e)
{
       if (e ==  0) __prof_trigger( 0);
  else if (e ==  1) __prof_trigger( 1);
  else if (e ==  2) __prof_trigger( 2);
  else if (e ==  3) __prof_trigger( 3);
  else if (e ==  4) __prof_trigger( 4);
  else if (e ==  5) __prof_trigger( 5);
  else if (e ==  6) __prof_trigger( 6);
  else if (e ==  7) __prof_trigger( 7);
  else if (e ==  8) __prof_trigger( 8);
  else if (e ==  9) __prof_trigger( 9);
  else if (e == 10) __prof_trigger(10);
  else if (e == 11) __prof_trigger(11);
  else if (e == 12) __prof_trigger(12);
  else if (e == 13) __prof_trigger(13);
  else if (e == 14) __prof_trigger(14);
  else if (e == 15) __prof_trigger(15);
}

static __inline __declspec(__device__) void threadfence(bool global = true)
{
  global ? __threadfence() : __threadfence_block();
}

static __inline __declspec(__device__) int float2int(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2int_rn(a) :
         mode == cudaRoundPosInf  ? __float2int_ru(a) :
         mode == cudaRoundMinInf  ? __float2int_rd(a) :
                                    __float2int_rz(a);
}

static __inline __declspec(__device__) unsigned int float2uint(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2uint_rn(a) :
         mode == cudaRoundPosInf  ? __float2uint_ru(a) :
         mode == cudaRoundMinInf  ? __float2uint_rd(a) :
                                    __float2uint_rz(a);
}

static __inline __declspec(__device__) float int2float(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __int2float_rz(a) :
         mode == cudaRoundPosInf ? __int2float_ru(a) :
         mode == cudaRoundMinInf ? __int2float_rd(a) :
                                   __int2float_rn(a);
}

static __inline __declspec(__device__) float uint2float(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero   ? __uint2float_rz(a) :
         mode == cudaRoundPosInf ? __uint2float_ru(a) :
         mode == cudaRoundMinInf ? __uint2float_rd(a) :
                                   __uint2float_rn(a);
}











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 2589 "c:\\cuda\\include\\device_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\sm_11_atomic_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */








/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 50 "c:\\cuda\\include\\sm_11_atomic_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 51 "c:\\cuda\\include\\sm_11_atomic_functions.h"

extern "C"
{

/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicAdd(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicExch(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) float        __fAtomicExch(float *address, float val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicMin(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicMax(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicAnd(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicOr(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicXor(int *address, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) int          __iAtomicCAS(int *address, int compare, int val);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);

}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline __declspec(__device__) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline __declspec(__device__) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline __declspec(__device__) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline __declspec(__device__) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline __declspec(__device__) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline __declspec(__device__) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline __declspec(__device__) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline __declspec(__device__) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline __declspec(__device__) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline __declspec(__device__) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline __declspec(__device__) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline __declspec(__device__) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline __declspec(__device__) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline __declspec(__device__) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline __declspec(__device__) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline __declspec(__device__) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}

#line 208 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 210 "c:\\cuda\\include\\sm_11_atomic_functions.h"

#line 212 "c:\\cuda\\include\\sm_11_atomic_functions.h"
#line 2597 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_12_atomic_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































#line 101 "c:\\cuda\\include\\sm_12_atomic_functions.h"

#line 103 "c:\\cuda\\include\\sm_12_atomic_functions.h"

#line 105 "c:\\cuda\\include\\sm_12_atomic_functions.h"
#line 2598 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_13_double_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/





















































































































































































































#line 258 "c:\\cuda\\include\\sm_13_double_functions.h"










































































































































































































































































































































































































































































































































#line 781 "c:\\cuda\\include\\sm_13_double_functions.h"

#line 783 "c:\\cuda\\include\\sm_13_double_functions.h"
#line 2599 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_20_atomic_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




































#line 72 "c:\\cuda\\include\\sm_20_atomic_functions.h"

#line 74 "c:\\cuda\\include\\sm_20_atomic_functions.h"

#line 76 "c:\\cuda\\include\\sm_20_atomic_functions.h"
#line 2600 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\sm_20_intrinsics.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */













































































































#line 145 "c:\\cuda\\include\\sm_20_intrinsics.h"

#line 147 "c:\\cuda\\include\\sm_20_intrinsics.h"

#line 149 "c:\\cuda\\include\\sm_20_intrinsics.h"
#line 2601 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\surface_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\surface_functions.h"
#line 1 "c:\\cuda\\include\\cuda_surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















































#line 87 "c:\\cuda\\include\\cuda_surface_types.h"
#line 49 "c:\\cuda\\include\\surface_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 50 "c:\\cuda\\include\\surface_functions.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 51 "c:\\cuda\\include\\surface_functions.h"
#line 1 "c:\\cuda\\include\\vector_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




































































































































































































































































#line 296 "c:\\cuda\\include\\vector_functions.h"
#line 52 "c:\\cuda\\include\\surface_functions.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 53 "c:\\cuda\\include\\surface_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar1     __surf1Dreadc1(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar2     __surf1Dreadc2(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar4     __surf1Dreadc4(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort1    __surf1Dreads1(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort2    __surf1Dreads2(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort4    __surf1Dreads4(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint1      __surf1Dreadu1(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint2      __surf1Dreadu2(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint4      __surf1Dreadu4(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ulonglong1 __surf1Dreadl1(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ulonglong2 __surf1Dreadl2(surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);








#line 91 "c:\\cuda\\include\\surface_functions.h"




#line 96 "c:\\cuda\\include\\surface_functions.h"

template<class T>
static __inline __declspec(__device__) void surf1Dread(T *res, surface<void, 1> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf1Dreads1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline __declspec(__device__) T surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf1Dread(&tmp, surf, x, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __inline __declspec(__device__) void surf1Dread(T *res, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1Dread<T>(surf, x, mode);
}

template<>
__inline __declspec(__device__) char surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) signed char surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned char surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) char1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) uchar1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) char2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline __declspec(__device__) uchar2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) char4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline __declspec(__device__) uchar4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned short surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) short1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ushort1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline __declspec(__device__) ushort2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline __declspec(__device__) ushort4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) int1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) uint1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline __declspec(__device__) uint2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline __declspec(__device__) uint4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) long long int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned long long int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) longlong1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ulonglong1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) longlong2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline __declspec(__device__) ulonglong2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);
}



template<>
__inline __declspec(__device__) long int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned long int surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) long1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ulong1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) long2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__inline __declspec(__device__) ulong2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__inline __declspec(__device__) long4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__inline __declspec(__device__) ulong4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 383 "c:\\cuda\\include\\surface_functions.h"

template<>
__inline __declspec(__device__) float surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) float1 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x));
}

template<>
__inline __declspec(__device__) float2 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline __declspec(__device__) float4 surf1Dread(surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar1     __surf2Dreadc1(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar2     __surf2Dreadc2(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uchar4     __surf2Dreadc4(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort1    __surf2Dreads1(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort2    __surf2Dreads2(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ushort4    __surf2Dreads4(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint1      __surf2Dreadu1(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint2      __surf2Dreadu2(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) uint4      __surf2Dreadu4(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ulonglong1 __surf2Dreadl1(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) ulonglong2 __surf2Dreadl2(surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);








#line 451 "c:\\cuda\\include\\surface_functions.h"




#line 456 "c:\\cuda\\include\\surface_functions.h"

template<class T>
static __inline __declspec(__device__) void surf2Dread(T *res, surface<void, 2> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s ==  1) ? (void)(*(uchar1 *)res = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(*(ushort1*)res = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(*(uint1  *)res = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(*(uint2  *)res = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4  *)res = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline __declspec(__device__) T surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;
  
  surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode);
  
  return tmp;
}

template<class T>
static __inline __declspec(__device__) void surf2Dread(T *res, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2Dread<T>(surf, x, y, mode);
}

template<>
__inline __declspec(__device__) char surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) signed char surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned char surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) char1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) uchar1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) char2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline __declspec(__device__) uchar2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) char4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline __declspec(__device__) uchar4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned short surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) short1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ushort1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline __declspec(__device__) ushort2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) short4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline __declspec(__device__) ushort4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) int1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) uint1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline __declspec(__device__) uint2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) int4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline __declspec(__device__) uint4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) long long int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned long long int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) longlong1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ulonglong1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline __declspec(__device__) longlong2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline __declspec(__device__) ulonglong2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);
}



template<>
__inline __declspec(__device__) long int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) unsigned long int surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (unsigned long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline __declspec(__device__) long1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_long1((long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) ulong1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_ulong1((unsigned long int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) long2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_long2((long int)tmp.x, (long int)tmp.y);
}

template<>
__inline __declspec(__device__) ulong2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_ulong2((unsigned long int)tmp.x, (unsigned long int)tmp.y);
}

template<>
__inline __declspec(__device__) long4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_long4((long int)tmp.x, (long int)tmp.y, (long int)tmp.z, (long int)tmp.w);
}

template<>
__inline __declspec(__device__) ulong4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_ulong4((unsigned long int)tmp.x, (unsigned long int)tmp.y, (unsigned long int)tmp.z, (unsigned long int)tmp.w);
}

#line 743 "c:\\cuda\\include\\surface_functions.h"

template<>
__inline __declspec(__device__) float surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline __declspec(__device__) float1 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x));
}

template<>
__inline __declspec(__device__) float2 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
  
  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline __declspec(__device__) float4 surf2Dread(surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
  
  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwritec1(    uchar1 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwritec2(    uchar2 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwritec4(    uchar4 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwrites1(   ushort1 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwrites2(   ushort2 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwrites4(   ushort4 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwriteu1(     uint1 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwriteu2(     uint2 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwriteu4(     uint4 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwritel1(ulonglong1 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf1Dwritel2(ulonglong2 val, surface<void, 1> t, int x, enum cudaSurfaceBoundaryMode mode);








#line 811 "c:\\cuda\\include\\surface_functions.h"




#line 816 "c:\\cuda\\include\\surface_functions.h"

template<class T>
static __inline __declspec(__device__) void surf1Dwrite(T val, surface<void, 1> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline __declspec(__device__) void surf1Dwrite(T val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1Dwrite(val, surf, x, (int)sizeof(T), mode);
}


static __inline __declspec(__device__) void surf1Dwrite(char val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(signed char val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(unsigned char val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(char1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uchar1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(char2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uchar2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(char4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uchar4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(short val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(unsigned short val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(short1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ushort1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(short2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ushort2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(short4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ushort4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(unsigned int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(int1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uint1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(int2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uint2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(int4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(uint4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(long long int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(unsigned long long int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(longlong1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ulonglong1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(longlong2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ulonglong2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap);
}



static __inline __declspec(__device__) void surf1Dwrite(long int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(unsigned long int val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(long1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ulong1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(long2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ulong2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(long4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(ulong4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

#line 1044 "c:\\cuda\\include\\surface_functions.h"

static __inline __declspec(__device__) void surf1Dwrite(float val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(float1 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(float2 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf1Dwrite(float4 val, surface<void, 1> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwritec1(    uchar1 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwritec2(    uchar2 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwritec4(    uchar4 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwrites1(   ushort1 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwrites2(   ushort2 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwrites4(   ushort4 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwriteu1(     uint1 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwriteu2(     uint2 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwriteu4(     uint4 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwritel1(ulonglong1 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
/*DEVICE_BUILTIN*/
extern __declspec(__device__) void __surf2Dwritel2(ulonglong2 val, surface<void, 2> t, int x, int y, enum cudaSurfaceBoundaryMode mode);








#line 1104 "c:\\cuda\\include\\surface_functions.h"




#line 1109 "c:\\cuda\\include\\surface_functions.h"

template<class T>
static __inline __declspec(__device__) void surf2Dwrite(T val, surface<void, 2> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T       val;
    uchar1  c1;
    ushort1 s1;
    uint1   u1;
    uint2   u2;
    uint4   u4;
  } tmp;
  
  tmp.val = val;
  
  (s ==  1) ? (void)(__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  2) ? (void)(__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  4) ? (void)(__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) :
  (s ==  8) ? (void)(__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline __declspec(__device__) void surf2Dwrite(T val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode);
}


static __inline __declspec(__device__) void surf2Dwrite(char val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(signed char val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(unsigned char val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(char1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uchar1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(char2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uchar2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(char4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uchar4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(short val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(unsigned short val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(short1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ushort1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(short2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ushort2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(short4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ushort4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(unsigned int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(int1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uint1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(int2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uint2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(int4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(uint4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(long long int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(unsigned long long int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(longlong1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ulonglong1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(longlong2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ulonglong2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap);
}



static __inline __declspec(__device__) void surf2Dwrite(long int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(unsigned long int val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(long1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ulong1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(long2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ulong2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(long4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(ulong4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

#line 1337 "c:\\cuda\\include\\surface_functions.h"

static __inline __declspec(__device__) void surf2Dwrite(float val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(float1 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(float2 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline __declspec(__device__) void surf2Dwrite(float4 val, surface<void, 2> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/
















































#line 1414 "c:\\cuda\\include\\surface_functions.h"

#line 1416 "c:\\cuda\\include\\surface_functions.h"

#line 2602 "c:\\cuda\\include\\device_functions.h"
#line 1 "c:\\cuda\\include\\texture_fetch_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\builtin_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

#line 1 "c:\\cuda\\include\\device_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */



















#line 55 "c:\\cuda\\include\\device_types.h"
#line 43 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\driver_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */






























































































































































































































































































































































































































#line 450 "c:\\cuda\\include\\driver_types.h"
#line 44 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\surface_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */







































#line 75 "c:\\cuda\\include\\surface_types.h"
#line 45 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 46 "c:\\cuda\\include\\builtin_types.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 47 "c:\\cuda\\include\\builtin_types.h"
#line 48 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\cuda_texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */
























































#line 92 "c:\\cuda\\include\\cuda_texture_types.h"
#line 49 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\host_defines.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

















































































































#line 149 "c:\\cuda\\include\\host_defines.h"
#line 50 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\texture_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */


















































#line 86 "c:\\cuda\\include\\texture_types.h"
#line 51 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\vector_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




































































































































































































































































#line 296 "c:\\cuda\\include\\vector_functions.h"
#line 52 "c:\\cuda\\include\\texture_fetch_functions.h"
#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 53 "c:\\cuda\\include\\texture_fetch_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/*DEVICE_BUILTIN*/
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__)  uint4 __utexfetchi(texture<T, 1, readMode> t, int4 i);
/*DEVICE_BUILTIN*/
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__)   int4 __itexfetchi(texture<T, 1, readMode> t, int4 i);
/*DEVICE_BUILTIN*/
template<class T, enum cudaTextureReadMode readMode> extern __declspec(__device__) float4 __ftexfetchi(texture<T, 1, readMode> t, int4 i);

/*DEVICE_BUILTIN*/
template<class T, int dim, enum cudaTextureReadMode readMode> extern __declspec(__device__)  uint4 __utexfetch(texture<T, dim, readMode> t, float4 i, int d = dim);
/*DEVICE_BUILTIN*/
template<class T, int dim, enum cudaTextureReadMode readMode> extern __declspec(__device__)   int4 __itexfetch(texture<T, dim, readMode> t, float4 i, int d = dim);
/*DEVICE_BUILTIN*/
template<class T, int dim, enum cudaTextureReadMode readMode> extern __declspec(__device__) float4 __ftexfetch(texture<T, dim, readMode> t, float4 i, int d = dim);

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) char tex1Dfetch(texture<char, 1, cudaReadModeElementType> t, int x)
{


#line 85 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
#line 87 "c:\\cuda\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __inline __declspec(__device__) signed char tex1Dfetch(texture<signed char, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __inline __declspec(__device__) unsigned char tex1Dfetch(texture<unsigned char, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline __declspec(__device__) char1 tex1Dfetch(texture<char1, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __inline __declspec(__device__) uchar1 tex1Dfetch(texture<uchar1, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline __declspec(__device__) char2 tex1Dfetch(texture<char2, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline __declspec(__device__) uchar2 tex1Dfetch(texture<uchar2, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline __declspec(__device__) char4 tex1Dfetch(texture<char4, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uchar4 tex1Dfetch(texture<uchar4, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) short tex1Dfetch(texture<short, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (short)v.x;
}

static __inline __declspec(__device__) unsigned short tex1Dfetch(texture<unsigned short, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline __declspec(__device__) short1 tex1Dfetch(texture<short1, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __inline __declspec(__device__) ushort1 tex1Dfetch(texture<ushort1, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline __declspec(__device__) short2 tex1Dfetch(texture<short2, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline __declspec(__device__) ushort2 tex1Dfetch(texture<ushort2, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline __declspec(__device__) short4 tex1Dfetch(texture<short4, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ushort4 tex1Dfetch(texture<ushort4, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int tex1Dfetch(texture<int, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (int)v.x;
}

static __inline __declspec(__device__) unsigned int tex1Dfetch(texture<unsigned int, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline __declspec(__device__) int1 tex1Dfetch(texture<int1, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __inline __declspec(__device__) uint1 tex1Dfetch(texture<uint1, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline __declspec(__device__) int2 tex1Dfetch(texture<int2, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline __declspec(__device__) uint2 tex1Dfetch(texture<uint2, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline __declspec(__device__) int4 tex1Dfetch(texture<int4, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uint4 tex1Dfetch(texture<uint4, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) long tex1Dfetch(texture<long, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (long)v.x;
}

static __inline __declspec(__device__) unsigned long tex1Dfetch(texture<unsigned long, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __inline __declspec(__device__) long1 tex1Dfetch(texture<long1, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __inline __declspec(__device__) ulong1 tex1Dfetch(texture<ulong1, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __inline __declspec(__device__) long2 tex1Dfetch(texture<long2, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __inline __declspec(__device__) ulong2 tex1Dfetch(texture<ulong2, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __inline __declspec(__device__) long4 tex1Dfetch(texture<long4, 1, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ulong4 tex1Dfetch(texture<ulong4, 1, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 336 "c:\\cuda\\include\\texture_fetch_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1Dfetch(texture<float, 1, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return v.x;
}

static __inline __declspec(__device__) float1 tex1Dfetch(texture<float1, 1, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __inline __declspec(__device__) float2 tex1Dfetch(texture<float2, 1, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline __declspec(__device__) float4 tex1Dfetch(texture<float4, 1, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1Dfetch(texture<char, 1, cudaReadModeNormalizedFloat> t, int x)
{


#line 382 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
#line 384 "c:\\cuda\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1Dfetch(texture<signed char, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1Dfetch(texture<unsigned char, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex1Dfetch(texture<char1, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex1Dfetch(texture<uchar1, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex1Dfetch(texture<char2, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex1Dfetch(texture<uchar2, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex1Dfetch(texture<char4, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex1Dfetch(texture<uchar4, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1Dfetch(texture<short, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1Dfetch(texture<unsigned short, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex1Dfetch(texture<short1, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex1Dfetch(texture<ushort1, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex1Dfetch(texture<short2, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex1Dfetch(texture<ushort2, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v  = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex1Dfetch(texture<short4, 1, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v   = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex1Dfetch(texture<ushort4, 1, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v   = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) char tex1D(texture<char, 1, cudaReadModeElementType> t, float x)
{


#line 534 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
#line 536 "c:\\cuda\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __inline __declspec(__device__) signed char tex1D(texture<signed char, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __inline __declspec(__device__) unsigned char tex1D(texture<unsigned char, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline __declspec(__device__) char1 tex1D(texture<char1, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __inline __declspec(__device__) uchar1 tex1D(texture<uchar1, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline __declspec(__device__) char2 tex1D(texture<char2, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline __declspec(__device__) uchar2 tex1D(texture<uchar2, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline __declspec(__device__) char4 tex1D(texture<char4, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uchar4 tex1D(texture<uchar4, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) short tex1D(texture<short, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (short)v.x;
}

static __inline __declspec(__device__) unsigned short tex1D(texture<unsigned short, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline __declspec(__device__) short1 tex1D(texture<short1, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __inline __declspec(__device__) ushort1 tex1D(texture<ushort1, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline __declspec(__device__) short2 tex1D(texture<short2, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline __declspec(__device__) ushort2 tex1D(texture<ushort2, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline __declspec(__device__) short4 tex1D(texture<short4, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ushort4 tex1D(texture<ushort4, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int tex1D(texture<int, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (int)v.x;
}

static __inline __declspec(__device__) unsigned int tex1D(texture<unsigned int, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline __declspec(__device__) int1 tex1D(texture<int1, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __inline __declspec(__device__) uint1 tex1D(texture<uint1, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline __declspec(__device__) int2 tex1D(texture<int2, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline __declspec(__device__) uint2 tex1D(texture<uint2, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline __declspec(__device__) int4 tex1D(texture<int4, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uint4 tex1D(texture<uint4, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) long tex1D(texture<long, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (long)v.x;
}

static __inline __declspec(__device__) unsigned long tex1D(texture<unsigned long, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned long)v.x;
}

static __inline __declspec(__device__) long1 tex1D(texture<long1, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long1(v.x);
}

static __inline __declspec(__device__) ulong1 tex1D(texture<ulong1, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong1(v.x);
}

static __inline __declspec(__device__) long2 tex1D(texture<long2, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long2(v.x, v.y);
}

static __inline __declspec(__device__) ulong2 tex1D(texture<ulong2, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __inline __declspec(__device__) long4 tex1D(texture<long4, 1, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ulong4 tex1D(texture<ulong4, 1, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 791 "c:\\cuda\\include\\texture_fetch_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1D(texture<float, 1, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return v.x;
}

static __inline __declspec(__device__) float1 tex1D(texture<float1, 1, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __inline __declspec(__device__) float2 tex1D(texture<float2, 1, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline __declspec(__device__) float4 tex1D(texture<float4, 1, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1D(texture<char, 1, cudaReadModeNormalizedFloat> t, float x)
{


#line 837 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
#line 839 "c:\\cuda\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1D(texture<signed char, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1D(texture<unsigned char, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex1D(texture<char1, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex1D(texture<uchar1, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex1D(texture<char2, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex1D(texture<uchar2, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex1D(texture<char4, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex1D(texture<uchar4, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex1D(texture<short, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex1D(texture<unsigned short, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex1D(texture<short1, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex1D(texture<ushort1, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex1D(texture<short2, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex1D(texture<ushort2, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v  = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex1D(texture<short4, 1, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v   = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex1D(texture<ushort4, 1, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v   = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
* 2D Texture functions                                                         *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) char tex2D(texture<char, 2, cudaReadModeElementType> t, float x, float y)
{


#line 989 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
#line 991 "c:\\cuda\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __inline __declspec(__device__) signed char tex2D(texture<signed char, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (signed char)v.x;
}

static __inline __declspec(__device__) unsigned char tex2D(texture<unsigned char, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned char)v.x;
}

static __inline __declspec(__device__) char1 tex2D(texture<char1, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char1(v.x);
}

static __inline __declspec(__device__) uchar1 tex2D(texture<uchar1, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar1(v.x);
}

static __inline __declspec(__device__) char2 tex2D(texture<char2, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline __declspec(__device__) uchar2 tex2D(texture<uchar2, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline __declspec(__device__) char4 tex2D(texture<char4, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uchar4 tex2D(texture<uchar4, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) short tex2D(texture<short, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (short)v.x;
}

static __inline __declspec(__device__) unsigned short tex2D(texture<unsigned short, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned short)v.x;
}

static __inline __declspec(__device__) short1 tex2D(texture<short1, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short1(v.x);
}

static __inline __declspec(__device__) ushort1 tex2D(texture<ushort1, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort1(v.x);
}

static __inline __declspec(__device__) short2 tex2D(texture<short2, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline __declspec(__device__) ushort2 tex2D(texture<ushort2, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline __declspec(__device__) short4 tex2D(texture<short4, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ushort4 tex2D(texture<ushort4, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int tex2D(texture<int, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (int)v.x;
}

static __inline __declspec(__device__) unsigned int tex2D(texture<unsigned int, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned int)v.x;
}

static __inline __declspec(__device__) int1 tex2D(texture<int1, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int1(v.x);
}

static __inline __declspec(__device__) uint1 tex2D(texture<uint1, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint1(v.x);
}

static __inline __declspec(__device__) int2 tex2D(texture<int2, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline __declspec(__device__) uint2 tex2D(texture<uint2, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline __declspec(__device__) int4 tex2D(texture<int4, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uint4 tex2D(texture<uint4, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) long tex2D(texture<long, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (long)v.x;
}

static __inline __declspec(__device__) unsigned long tex2D(texture<unsigned long, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned long)v.x;
}

static __inline __declspec(__device__) long1 tex2D(texture<long1, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long1(v.x);
}

static __inline __declspec(__device__) ulong1 tex2D(texture<ulong1, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong1(v.x);
}

static __inline __declspec(__device__) long2 tex2D(texture<long2, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long2(v.x, v.y);
}

static __inline __declspec(__device__) ulong2 tex2D(texture<ulong2, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong2(v.x, v.y);
}

static __inline __declspec(__device__) long4 tex2D(texture<long4, 2, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ulong4 tex2D(texture<ulong4, 2, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1240 "c:\\cuda\\include\\texture_fetch_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex2D(texture<float, 2, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return v.x;
}

static __inline __declspec(__device__) float1 tex2D(texture<float1, 2, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float1(v.x);
}

static __inline __declspec(__device__) float2 tex2D(texture<float2, 2, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline __declspec(__device__) float4 tex2D(texture<float4, 2, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex2D(texture<char, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{


#line 1286 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
#line 1288 "c:\\cuda\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex2D(texture<signed char, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex2D(texture<unsigned char, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex2D(texture<char1, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex2D(texture<uchar1, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex2D(texture<char2, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex2D(texture<uchar2, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex2D(texture<char4, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex2D(texture<uchar4, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex2D(texture<short, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex2D(texture<unsigned short, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex2D(texture<short1, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex2D(texture<ushort1, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex2D(texture<short2, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex2D(texture<ushort2, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex2D(texture<short4, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v   = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex2D(texture<ushort4, 2, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
* 3D Texture functions                                                         *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) char tex3D(texture<char, 3, cudaReadModeElementType> t, float x, float y, float z)
{


#line 1438 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
#line 1440 "c:\\cuda\\include\\texture_fetch_functions.h"

  return (char)v.x;
}

static __inline __declspec(__device__) signed char tex3D(texture<signed char, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __inline __declspec(__device__) unsigned char tex3D(texture<unsigned char, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __inline __declspec(__device__) char1 tex3D(texture<char1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __inline __declspec(__device__) uchar1 tex3D(texture<uchar1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __inline __declspec(__device__) char2 tex3D(texture<char2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __inline __declspec(__device__) uchar2 tex3D(texture<uchar2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __inline __declspec(__device__) char4 tex3D(texture<char4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uchar4 tex3D(texture<uchar4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) short tex3D(texture<short, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __inline __declspec(__device__) unsigned short tex3D(texture<unsigned short, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __inline __declspec(__device__) short1 tex3D(texture<short1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __inline __declspec(__device__) ushort1 tex3D(texture<ushort1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __inline __declspec(__device__) short2 tex3D(texture<short2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __inline __declspec(__device__) ushort2 tex3D(texture<ushort2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __inline __declspec(__device__) short4 tex3D(texture<short4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ushort4 tex3D(texture<ushort4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) int tex3D(texture<int, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __inline __declspec(__device__) unsigned int tex3D(texture<unsigned int, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __inline __declspec(__device__) int1 tex3D(texture<int1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __inline __declspec(__device__) uint1 tex3D(texture<uint1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __inline __declspec(__device__) int2 tex3D(texture<int2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __inline __declspec(__device__) uint2 tex3D(texture<uint2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __inline __declspec(__device__) int4 tex3D(texture<int4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) uint4 tex3D(texture<uint4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) long tex3D(texture<long, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (long)v.x;
}

static __inline __declspec(__device__) unsigned long tex3D(texture<unsigned long, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned long)v.x;
}

static __inline __declspec(__device__) long1 tex3D(texture<long1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long1(v.x);
}

static __inline __declspec(__device__) ulong1 tex3D(texture<ulong1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong1(v.x);
}

static __inline __declspec(__device__) long2 tex3D(texture<long2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long2(v.x, v.y);
}

static __inline __declspec(__device__) ulong2 tex3D(texture<ulong2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong2(v.x, v.y);
}

static __inline __declspec(__device__) long4 tex3D(texture<long4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_long4(v.x, v.y, v.z, v.w);
}

static __inline __declspec(__device__) ulong4 tex3D(texture<ulong4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ulong4(v.x, v.y, v.z, v.w);
}

#line 1689 "c:\\cuda\\include\\texture_fetch_functions.h"

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex3D(texture<float, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return v.x;
}

static __inline __declspec(__device__) float1 tex3D(texture<float1, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __inline __declspec(__device__) float2 tex3D(texture<float2, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __inline __declspec(__device__) float4 tex3D(texture<float4, 3, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex3D(texture<char, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{


#line 1735 "c:\\cuda\\include\\texture_fetch_functions.h"
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
#line 1737 "c:\\cuda\\include\\texture_fetch_functions.h"
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex3D(texture<signed char, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex3D(texture<unsigned char, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex3D(texture<char1, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex3D(texture<uchar1, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex3D(texture<char2, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex3D(texture<uchar2, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex3D(texture<char4, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex3D(texture<uchar4, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__device__) float tex3D(texture<short, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float tex3D(texture<unsigned short, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline __declspec(__device__) float1 tex3D(texture<short1, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float1 tex3D(texture<ushort1, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline __declspec(__device__) float2 tex3D(texture<short2, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float2 tex3D(texture<ushort2, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v  = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline __declspec(__device__) float4 tex3D(texture<short4, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v   = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline __declspec(__device__) float4 tex3D(texture<ushort4, 3, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v   = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}





























#line 1905 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 1907 "c:\\cuda\\include\\texture_fetch_functions.h"

#line 2603 "c:\\cuda\\include\\device_functions.h"

#line 2605 "c:\\cuda\\include\\device_functions.h"

#line 66 "C:\\CUDA\\include\\cuda_runtime.h"
#line 1 "c:\\cuda\\include\\device_launch_parameters.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */




#line 1 "c:\\cuda\\include\\vector_types.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

































































































































































































































































































































































































































































#line 485 "c:\\cuda\\include\\vector_types.h"
#line 40 "c:\\cuda\\include\\device_launch_parameters.h"






#line 47 "c:\\cuda\\include\\device_launch_parameters.h"


extern "C" {
#line 51 "c:\\cuda\\include\\device_launch_parameters.h"

/*DEVICE_BUILTIN*/
uint3 extern const threadIdx;
/*DEVICE_BUILTIN*/
uint3 extern const blockIdx;
/*DEVICE_BUILTIN*/
dim3 extern const blockDim;
/*DEVICE_BUILTIN*/
dim3 extern const gridDim;
/*DEVICE_BUILTIN*/
int extern const warpSize;




}
#line 68 "c:\\cuda\\include\\device_launch_parameters.h"






#line 75 "c:\\cuda\\include\\device_launch_parameters.h"






#line 82 "c:\\cuda\\include\\device_launch_parameters.h"






#line 89 "c:\\cuda\\include\\device_launch_parameters.h"






#line 96 "c:\\cuda\\include\\device_launch_parameters.h"






#line 103 "c:\\cuda\\include\\device_launch_parameters.h"

#line 105 "c:\\cuda\\include\\device_launch_parameters.h"
#line 67 "C:\\CUDA\\include\\cuda_runtime.h"

#line 69 "C:\\CUDA\\include\\cuda_runtime.h"



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief \hl Configure a device launch
 *
 * Pushes \p size bytes of the argument pointed to by \p arg at \p offset
 * bytes from the start of the parameter passing area, which starts at
 * offset 0. The arguments are stored in the top of the execution stack.
 * \ref ::cudaSetupArgument(T,size_t) "cudaSetupArgument()" must be preceded
 * by a call to ::cudaConfigureCall().
 *
 * \param arg    - Argument to push for a kernel launch
 * \param offset - Offset in argument stack to push new arg
 *
 * \return
 * ::cudaSuccess
 * \notefnerr
 *
 * \sa ::cudaConfigureCall,
 * \ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, T*) "cudaFuncGetAttributes (C++ API)",
 * \ref ::cudaLaunch(T*) "cudaLaunch (C++ API)",
 * ::cudaSetDoubleForDevice,
 * ::cudaSetDoubleForHost,
 * \ref ::cudaSetupArgument(const void*, size_t, size_t) "cudaSetupArgument (C API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaSetupArgument(
  T      arg,
  size_t offset
)
{
  return cudaSetupArgument((const void*)&arg, sizeof(T), offset);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostAlloc(
  T            **ptr,
  size_t         size,
  unsigned int   flags
)
{
  return cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaHostGetDevicePointer(
  T            **pDevice,
  void          *pHost,
  unsigned int  flags
)
{
  return cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMalloc(
  T      **devPtr,
  size_t   size
)
{
  return cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocHost(
  T      **ptr,
  size_t   size
)
{
  return cudaMallocHost((void**)(void*)ptr, size);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMallocPitch(
  T      **devPtr,
  size_t  *pitch,
  size_t   width,
  size_t   height
)
{
  return cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}



/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \addtogroup CUDART_HIGHLEVEL
 * @{
 */

static __inline __declspec(__host__) cudaError_t cudaMemcpyToSymbol(
        char                *symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice
)
{
  return cudaMemcpyToSymbol((const char*)symbol, src, count, offset, kind);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbol(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice
)
{
  return cudaMemcpyToSymbol((const char*)&symbol, src, count, offset, kind);
}

static __inline __declspec(__host__) cudaError_t cudaMemcpyToSymbolAsync(
        char                *symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice,
        cudaStream_t         stream = 0
)
{
  return cudaMemcpyToSymbolAsync((const char*)symbol, src, count, offset, kind, stream);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyToSymbolAsync(
  const T                   &symbol,
  const void                *src,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyHostToDevice,
        cudaStream_t         stream = 0
)
{
  return cudaMemcpyToSymbolAsync((const char*)&symbol, src, count, offset, kind, stream);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbol(
  void                *dst,
  char                *symbol,
  size_t               count,
  size_t               offset = 0,
  enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost
)
{
  return cudaMemcpyFromSymbol(dst, (const char*)symbol, count, offset, kind);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbol(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost
)
{
  return cudaMemcpyFromSymbol(dst, (const char*)&symbol, count, offset, kind);
}

static __inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbolAsync(
  void                *dst,
  char                *symbol,
  size_t               count,
  size_t               offset = 0,
  enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost,
  cudaStream_t         stream = 0
)
{
  return cudaMemcpyFromSymbolAsync(dst, (const char*)symbol, count, offset, kind, stream);
}

template<class T>
__inline __declspec(__host__) cudaError_t cudaMemcpyFromSymbolAsync(
        void                *dst,
  const T                   &symbol,
        size_t               count,
        size_t               offset = 0,
        enum cudaMemcpyKind  kind   = cudaMemcpyDeviceToHost,
        cudaStream_t         stream = 0
)
{
  return cudaMemcpyFromSymbolAsync(dst, (const char*)&symbol, count, offset, kind, stream);
}

static __inline __declspec(__host__) cudaError_t cudaGetSymbolAddress(
  void **devPtr,
  char  *symbol
)
{
  return cudaGetSymbolAddress(devPtr, (const char*)symbol);
}

/**
 * \brief \hl Finds the address associated with a CUDA symbol
 *
 * Returns in \p *devPtr the address of symbol \p symbol on the device.
 * \p symbol can either be a variable that resides in global or constant memory space, or
 * it can be a character string, naming a variable that resides in global or constant
 * memory space. If \p symbol cannot be found, or if \p symbol is not declared
 * in the global or constant memory space, \p *devPtr is unchanged and the error
 * ::cudaErrorInvalidSymbol is returned. If there are multiple global or constant
 * variables with the same string name (from separate files) and the lookup
 * is done via character string, ::cudaErrorDuplicateVariableName is
 * returned.
 *
 * \param devPtr - Return device pointer associated with symbol
 * \param symbol - Global/constant variable or string symbol to search for
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidSymbol,
 * ::cudaErrorDuplicateVariableName
 * \notefnerr
 *
 * \sa \ref ::cudaGetSymbolAddress(void**, const char*) "cudaGetSymbolAddress (C API)"
 * \ref ::cudaGetSymbolSize(size_t*, const T&) "cudaGetSymbolSize (C++ API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T     &symbol
)
{
  return cudaGetSymbolAddress(devPtr, (const char*)&symbol);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

static __inline __declspec(__host__) cudaError_t cudaGetSymbolSize(
  size_t *size,
  char   *symbol
)
{
  return cudaGetSymbolSize(size, (const char*)symbol);
}

/**
 * \brief \hl Finds the size of the object associated with a CUDA symbol
 *
 * Returns in \p *size the size of symbol \p symbol. \p symbol can either be a
 * variable that resides in global or constant memory space, or it can be a
 * character string, naming a variable that resides in global or constant
 * memory space. If \p symbol cannot be found, or if \p symbol is not declared
 * in global or constant memory space, \p *size is unchanged and the error
 * ::cudaErrorInvalidSymbol is returned. If there are multiple global
 * variables with the same string name (from separate files) and the lookup
 * is done via character string, ::cudaErrorDuplicateVariableName is
 * returned.
 *
 * \param size   - Size of object associated with symbol
 * \param symbol - Global variable or string symbol to find size of
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidSymbol,
 * ::cudaErrorDuplicateVariableName
 * \notefnerr
 *
 * \sa \ref ::cudaGetSymbolAddress(void**, const T&) "cudaGetSymbolAddress (C++ API)"
 * \ref ::cudaGetSymbolSize(size_t*, const char*) "cudaGetSymbolSize (C API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T      &symbol
)
{
  return cudaGetSymbolSize(size, (const char*)&symbol);
}

/** @} */ /* END CUDART_HIGHLEVEL */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \addtogroup CUDART_HIGHLEVEL
 *
 * @{
 */

/**
 * \brief \hl Binds a memory area to a texture
 *
 * Binds \p size bytes of the memory area pointed to by \p devPtr to texture
 * reference \p tex. \p desc describes how the memory is interpreted when
 * fetching values from the texture. The \p offset parameter is an optional
 * byte offset as with the low-level
 * \ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) "cudaBindTexture()"
 * function. Any memory previously bound to \p tex is unbound.
 *
 * \param offset - Offset in bytes
 * \param tex    - Texture to bind
 * \param devPtr - Memory area on device
 * \param desc   - Channel format
 * \param size   - Size of the memory area pointed to by devPtr
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidDevicePointer,
 * ::cudaErrorInvalidTexture
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) "cudaBindTexture (C API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor)",
 * \ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode >&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
        size_t                            size = 0xffffffff
)
{
  return cudaBindTexture(offset, &tex, devPtr, &desc, size);
}

/**
 * \brief \hl Binds a memory area to a texture
 *
 * Binds \p size bytes of the memory area pointed to by \p devPtr to texture
 * reference \p tex. The channel descriptor is inherited from the texture
 * reference type. The \p offset parameter is an optional byte offset as with
 * the low-level
 * ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t)
 * function. Any memory previously bound to \p tex is unbound.
 *
 * \param offset - Offset in bytes
 * \param tex    - Texture to bind
 * \param devPtr - Memory area on device
 * \param size   - Size of the memory area pointed to by devPtr
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidDevicePointer,
 * ::cudaErrorInvalidTexture
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API),
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t) "cudaBindTexture (C API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor),
 * \ref ::cudaUnbindTexture(const struct texture<T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode>&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
        size_t                            size = 0xffffffff
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}

/**
 * \brief \hl Binds a 2D memory area to a texture
 *
 * Binds the 2D memory area pointed to by \p devPtr to the
 * texture reference \p tex. The size of the area is constrained by
 * \p width in texel units, \p height in texel units, and \p pitch in byte
 * units. \p desc describes how the memory is interpreted when fetching values
 * from the texture. Any memory previously bound to \p tex is unbound.
 *
 * Since the hardware enforces an alignment requirement on texture base
 * addresses,
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D()"
 * returns in \p *offset a byte offset that
 * must be applied to texture fetches in order to read from the desired memory.
 * This offset must be divided by the texel size and passed to kernels that
 * read from the texture so they can be applied to the ::tex2D() function.
 * If the device memory pointer was returned from ::cudaMalloc(), the offset is
 * guaranteed to be 0 and NULL may be passed as the \p offset parameter.
 *
 * \param offset - Offset in bytes
 * \param tex    - Texture reference to bind
 * \param devPtr - 2D memory area on device
 * \param desc   - Channel format
 * \param width  - Width in texel units
 * \param height - Height in texel units
 * \param pitch  - Pitch in bytes
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidDevicePointer,
 * ::cudaErrorInvalidTexture
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API),
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (C++ API),
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct textureReference*, const void*, const struct cudaChannelFormatDesc*, size_t, size_t, size_t) "cudaBindTexture2D (C API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor),
 * \ref ::cudaUnbindTexture(const struct texture<T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode>&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTexture2D(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex,
  const void                             *devPtr,
  const struct cudaChannelFormatDesc     &desc,
  size_t                                  width,
  size_t                                  height,
  size_t                                  pitch
)
{
  return cudaBindTexture2D( offset, &tex, devPtr, &desc, width, height, pitch);
}

/**
 * \brief \hl Binds an array to a texture
 *
 * Binds the CUDA array \p array to the texture reference \p tex.
 * \p desc describes how the memory is interpreted when fetching values from
 * the texture. Any CUDA array previously bound to \p tex is unbound.
 *
 * \param tex   - Texture to bind
 * \param array - Memory array on device
 * \param desc  - Channel format
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidDevicePointer,
 * ::cudaErrorInvalidTexture
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (C++ API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct textureReference*, const struct cudaArray*, const struct cudaChannelFormatDesc*) "cudaBindTextureToArray (C API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor)",
 * \ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode >&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  const struct cudaArray                 *array,
  const struct cudaChannelFormatDesc     &desc
)
{
  return cudaBindTextureToArray(&tex, array, &desc);
}

/**
 * \brief \hl Binds an array to a texture
 *
 * Binds the CUDA array \p array to the texture reference \p tex.
 * The channel descriptor is inherited from the CUDA array. Any CUDA array
 * previously bound to \p tex is unbound.
 *
 * \param tex   - Texture to bind
 * \param array - Memory array on device
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidDevicePointer,
 * ::cudaErrorInvalidTexture
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (C++ API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct textureReference*, const struct cudaArray*, const struct cudaChannelFormatDesc*) "cudaBindTextureToArray (C API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode >&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  const struct cudaArray                 *array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \brief \hl Unbinds a texture
 *
 * Unbinds the texture bound to \p tex.
 *
 * \param tex - Texture to unbind
 *
 * \return ::cudaSuccess
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (C++ API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor)",
 * \ref ::cudaUnbindTexture(const struct textureReference*) "cudaUnbindTexture (C API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct texture< T, dim, readMode >&) "cudaGetTextureAlignmentOffset (C++ API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return cudaUnbindTexture(&tex);
}

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \brief \hl Get the alignment offset of a texture
 *
 * Returns in \p *offset the offset that was returned when texture reference
 * \p tex was bound.
 *
 * \param offset - Offset of texture reference in bytes
 * \param tex    - Texture to get offset of
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidTexture,
 * ::cudaErrorInvalidTextureBinding
 * \notefnerr
 *
 * \sa \ref ::cudaCreateChannelDesc(void) "cudaCreateChannelDesc (C++ API)",
 * ::cudaGetChannelDesc, ::cudaGetTextureReference,
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t) "cudaBindTexture (C++ API)",
 * \ref ::cudaBindTexture(size_t*, const struct texture< T, dim, readMode>&, const void*, size_t) "cudaBindTexture (C++ API, inherited channel descriptor)",
 * \ref ::cudaBindTexture2D(size_t*, const struct texture< T, dim, readMode>&, const void*, const struct cudaChannelFormatDesc&, size_t, size_t, size_t) "cudaBindTexture2D (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindTextureToArray (C++ API)",
 * \ref ::cudaBindTextureToArray(const struct texture< T, dim, readMode>&, const struct cudaArray*) "cudaBindTextureToArray (C++ API, inherited channel descriptor)",
 * \ref ::cudaUnbindTexture(const struct texture< T, dim, readMode>&) "cudaUnbindTexture (C++ API)",
 * \ref ::cudaGetTextureAlignmentOffset(size_t*, const struct textureReference*) "cudaGetTextureAlignmentOffset (C API)"
 */
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline __declspec(__host__) cudaError_t cudaGetTextureAlignmentOffset(
        size_t                           *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return cudaGetTextureAlignmentOffset(offset, &tex);
}

/** @} */ /* END CUDART_HIGHLEVEL */

/*******************************************************************************
*                                                                              *
*                                                                              *
*                                                                              *
*******************************************************************************/

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief Sets the preferred cache configuration for a device function
 *
 * On devices where the L1 cache and shared memory use the same hardware
 * resources, this sets through \p cacheConfig the preferred cache configuration
 * for the function specified via \p func. This is only a preference. The
 * runtime will use the requested configuration if possible, but it is free to
 * choose a different configuration if required to execute \p func.
 *
 * \p func can either be a pointer to a function that executes
 * on the device, or it can be a character string specifying the 
 * fully-decorated (C++) name for a function that executes on the device. 
 * The parameter specified by \p func must be declared as a \p __global__ 
 * function. If the specified function does not exist,
 * then ::cudaErrorInvalidDeviceFunction is returned.
 *
 * This setting does nothing on devices where the size of the L1 cache and
 * shared memory are fixed.
 *
 * Switching between configuration modes may insert a device-side
 * synchronization point for streamed kernel launches. 
 *
 * \param func - Device char string naming device function
 * \param cacheConfig - Cache configuration mode
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInitializationError,
 * ::cudaErrorInvalidDeviceFunction
 * \notefnerr
 *
 * \sa ::cudaConfigureCall,
 * \ref ::cudaFuncSetCacheConfig(const char*, enum cudaFuncCache) "cudaFuncSetCacheConfig (C API)",
 * \ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, T*) "cudaFuncGetAttributes (C++ API)",
 * \ref ::cudaLaunch(const char*) "cudaLaunch (C API)",
 * ::cudaSetDoubleForDevice,
 * ::cudaSetDoubleForHost,
 * \ref ::cudaSetupArgument(T,size_t) "cudaSetupArgument (C++ API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncSetCacheConfig(
  T *func,
  enum cudaFuncCache cacheConfig
)
{
  return cudaFuncSetCacheConfig((const char*)func, cacheConfig);
}

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief \hl Launches a device function
 *
 * Launches the function \p entry on the device. The parameter \p entry can
 * either be a function that executes on the device, or it can be a character
 * string, naming a function that executes on the device. The parameter
 * specified by \p entry must be declared as a \p __global__ function.
 * \ref ::cudaLaunch(T*) "cudaLaunch()" must be preceded by a call to
 * ::cudaConfigureCall() since it pops the data that was pushed by
 * ::cudaConfigureCall() from the execution stack.
 *
 * \param entry - Device function pointer or char string naming device function
 * to execute
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidDeviceFunction,
 * ::cudaErrorInvalidConfiguration,
 * ::cudaErrorLaunchFailure,
 * ::cudaErrorPriorLaunchFailure,
 * ::cudaErrorLaunchTimeout,
 * ::cudaErrorLaunchOutOfResources,
 * ::cudaErrorSharedObjectSymbolNotFound,
 * ::cudaErrorSharedObjectInitFailed
 * \notefnerr
 *
 * \sa ::cudaConfigureCall,
 * \ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) "cudaFuncSetCacheConfig (C++ API)",
 * \ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, T*) "cudaFuncGetAttributes (C++ API)",
 * \ref ::cudaLaunch(const char*) "cudaLaunch (C API)",
 * ::cudaSetDoubleForDevice,
 * ::cudaSetDoubleForHost,
 * \ref ::cudaSetupArgument(T,size_t) "cudaSetupArgument (C++ API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaLaunch(
  T *entry
)
{
  return cudaLaunch((const char*)entry);
}

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief \hl Find out attributes for a given function
 *
 * This function obtains the attributes of a function specified via \p entry.
 * The parameter \p entry can either be a pointer to a function that executes
 * on the device, or it can be a character string specifying the
 * fully-decorated (C++) name of a function that executes on the device. The
 * parameter specified by \p entry must be declared as a \p __global__
 * function. The fetched attributes are placed in \p attr. If the specified
 * function does not exist, then ::cudaErrorInvalidDeviceFunction is returned.
 *
 * \param attr  - Return pointer to function's attributes
 * \param entry - Function to get attributes of
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInitializationError,
 * ::cudaErrorInvalidDeviceFunction
 * \notefnerr
 *
 * \sa ::cudaConfigureCall,
 * \ref ::cudaFuncSetCacheConfig(T*, enum cudaFuncCache) "cudaFuncSetCacheConfig (C++ API)",
 * \ref ::cudaFuncGetAttributes(struct cudaFuncAttributes*, const char*) "cudaFuncGetAttributes (C API)",
 * \ref ::cudaLaunch(T*) "cudaLaunch (C++ API)",
 * ::cudaSetDoubleForDevice,
 * ::cudaSetDoubleForHost,
 * \ref ::cudaSetupArgument(T,size_t) "cudaSetupArgument (C++ API)"
 */
template<class T>
__inline __declspec(__host__) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T *entry
)
{
  return cudaFuncGetAttributes(attr, (const char*)entry);
}

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief \hl Binds an array to a surface
 *
 * Binds the CUDA array \p array to the surface reference \p surf.
 * \p desc describes how the memory is interpreted when dealing with
 * the surface. Any CUDA array previously bound to \p surf is unbound.
 *
 * \param surf  - Surface to bind
 * \param array - Memory array on device
 * \param desc  - Channel format
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidSurface
 * \notefnerr
 *
 * \sa \ref ::cudaBindSurfaceToArray(const struct surfaceReference*, const struct cudaArray*, const struct cudaChannelFormatDesc*) "cudaBindSurfaceToArray (C API)",
 * \ref ::cudaBindSurfaceToArray(const struct surface< T, dim>&, const struct cudaArray*) "cudaBindSurfaceToArray (C++ API, inherited channel descriptor)"
 */
template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim>           &surf,
  const struct cudaArray                 *array,
  const struct cudaChannelFormatDesc     &desc
)
{
  return cudaBindSurfaceToArray(&surf, array, &desc);
}

/**
 * \ingroup CUDART_HIGHLEVEL
 * \brief \hl Binds an array to a surface
 *
 * Binds the CUDA array \p array to the surface reference \p surf.
 * The channel descriptor is inherited from the CUDA array. Any CUDA array
 * previously bound to \p surf is unbound.
 *
 * \param surf  - Surface to bind
 * \param array - Memory array on device
 *
 * \return
 * ::cudaSuccess,
 * ::cudaErrorInvalidValue,
 * ::cudaErrorInvalidSurface
 * \notefnerr
 *
 * \sa \ref ::cudaBindSurfaceToArray(const struct surfaceReference*, const struct cudaArray*, const struct cudaChannelFormatDesc*) "cudaBindSurfaceToArray (C API)",
 * \ref ::cudaBindSurfaceToArray(const struct surface< T, dim>&, const struct cudaArray*, const struct cudaChannelFormatDesc&) "cudaBindSurfaceToArray (C++ API)"
 */
template<class T, int dim>
__inline __declspec(__host__) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim>           &surf,
  const struct cudaArray                 *array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t                  err = cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}

#line 878 "C:\\CUDA\\include\\cuda_runtime.h"

#line 880 "C:\\CUDA\\include\\cuda_runtime.h"

#line 882 "C:\\CUDA\\include\\cuda_runtime.h"

#line 1 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/


#pragma once
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


extern "C" {
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


/* Buffered I/O macros */




/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */




/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */






struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


/* Directory where temporary files may be created. */







#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 * L_tmpnam_s = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 16 (for the filename string)
 *            + 1 (for the null terminator)
 */



#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"







/* Seek method constants */













#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

/* Define NULL pointer value */








/* Declare _iob[] array */


 FILE * __cdecl __iob_func(void);
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


/* Define file position type */







#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


/* At this point we could switch both to long long, but we won't do that till next version to avoid any potential compat issues */
typedef __int64 fpos_t;




#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


#line 158 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"






#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

















/* constants used by _set_output_format */


/* Function prototypes */



  int __cdecl _filbuf(   FILE * _File );
  int __cdecl _flsbuf(  int _Ch,    FILE * _File);




  FILE * __cdecl _fsopen(   const char * _Filename,    const char * _Mode,   int _ShFlag);
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

 void __cdecl clearerr(   FILE * _File);

  errno_t __cdecl clearerr_s(   FILE * _File );
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl fclose(   FILE * _File);
  int __cdecl _fcloseall(void);




  FILE * __cdecl _fdopen(  int _FileHandle,    const char * _Mode);
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  int __cdecl feof(  FILE * _File);
  int __cdecl ferror(  FILE * _File);
  int __cdecl fflush(   FILE * _File);
  int __cdecl fgetc(   FILE * _File);
  int __cdecl _fgetchar(void);
  int __cdecl fgetpos(   FILE * _File ,   fpos_t * _Pos);
  char * __cdecl fgets(    char * _Buf,   int _MaxCount,    FILE * _File);




  int __cdecl _fileno(  FILE * _File);
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"




#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  char * __cdecl _tempnam(   const char * _DirName,    const char * _FilePrefix);



#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  int __cdecl _flushall(void);
   FILE * __cdecl fopen(   const char * _Filename,    const char * _Mode);

  errno_t __cdecl fopen_s(     FILE ** _File,    const char * _Filename,    const char * _Mode);
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl fprintf(   FILE * _File,     const char * _Format, ...);

  int __cdecl fprintf_s(   FILE * _File,     const char * _Format, ...);
#line 245 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl fputc(  int _Ch,    FILE * _File);
  int __cdecl _fputchar(  int _Ch);
  int __cdecl fputs(   const char * _Str,    FILE * _File);
  size_t __cdecl fread(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,    FILE * _File);

  size_t __cdecl fread_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,    FILE * _File);
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
   FILE * __cdecl freopen(   const char * _Filename,    const char * _Mode,    FILE * _File);

  errno_t __cdecl freopen_s(     FILE ** _File,    const char * _Filename,    const char * _Mode,    FILE * _OldFile);
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
   int __cdecl fscanf(   FILE * _File,     const char * _Format, ...);
   int __cdecl _fscanf_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

  int __cdecl fscanf_s(   FILE * _File,     const char * _Format, ...);
#line 263 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _fscanf_s_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl fsetpos(   FILE * _File,   const fpos_t * _Pos);
  int __cdecl fseek(   FILE * _File,   long _Offset,   int _Origin);
  long __cdecl ftell(   FILE * _File);

  int __cdecl _fseeki64(   FILE * _File,   __int64 _Offset,   int _Origin);
  __int64 __cdecl _ftelli64(   FILE * _File);

  size_t __cdecl fwrite(   const void * _Str,   size_t _Size,   size_t _Count,    FILE * _File);
  int __cdecl getc(   FILE * _File);
  int __cdecl getchar(void);
  int __cdecl _getmaxstdio(void);

 char * __cdecl gets_s(    char * _Buf,   rsize_t _Size);
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) { return gets_s(_Buffer, _Size); } }
  char * __cdecl gets(  char *_Buffer);
 int __cdecl _getw(   FILE * _File);




  int __cdecl _pclose(   FILE * _File);
  FILE * __cdecl _popen(   const char * _Command,    const char * _Mode);
  int __cdecl printf(    const char * _Format, ...);

  int __cdecl printf_s(    const char * _Format, ...);
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl putc(  int _Ch,    FILE * _File);
  int __cdecl putchar(  int _Ch);
  int __cdecl puts(   const char * _Str);
  int __cdecl _putw(  int _Word,    FILE * _File);


  int __cdecl remove(   const char * _Filename);
  int __cdecl rename(   const char * _OldFilename,    const char * _NewFilename);
  int __cdecl _unlink(   const char * _Filename);

   int __cdecl unlink(   const char * _Filename);
#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
 void __cdecl rewind(   FILE * _File);
  int __cdecl _rmtmp(void);
   int __cdecl scanf(    const char * _Format, ...);
   int __cdecl _scanf_l(    const char * _Format,    _locale_t _Locale, ...);

  int __cdecl scanf_s(    const char * _Format, ...);
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _scanf_s_l(    const char * _Format,    _locale_t _Locale, ...);
  void __cdecl setbuf(   FILE * _File,      char * _Buffer);
  int __cdecl _setmaxstdio(  int _Max);
  unsigned int __cdecl _set_output_format(  unsigned int _Format);
  unsigned int __cdecl _get_output_format(void);
  int __cdecl setvbuf(   FILE * _File,     char * _Buf,   int _Mode,   size_t _Size);
  int __cdecl _snprintf_s(    char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, ...) { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }

  int __cdecl sprintf_s(    char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, ...);
#line 322 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(char (&_Dest)[_Size],     const char * _Format, ...) { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
  int __cdecl _scprintf(    const char * _Format, ...);
   int __cdecl sscanf(   const char * _Src,     const char * _Format, ...);
   int __cdecl _sscanf_l(   const char * _Src,     const char * _Format,    _locale_t _Locale, ...);

  int __cdecl sscanf_s(   const char * _Src,     const char * _Format, ...);
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _sscanf_s_l(   const char * _Src,     const char * _Format,    _locale_t _Locale, ...);
   int __cdecl _snscanf(     const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
   int __cdecl _snscanf_l(     const char * _Src,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _snscanf_s(     const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
  int __cdecl _snscanf_s_l(     const char * _Src,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
   FILE * __cdecl tmpfile(void);

  errno_t __cdecl tmpfile_s(    FILE ** _File);
  errno_t __cdecl tmpnam_s(    char * _Buf,   rsize_t _Size);
#line 339 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buf)[_Size]) { return tmpnam_s(_Buf, _Size); } }
  char * __cdecl tmpnam(  char *_Buffer);
  int __cdecl ungetc(  int _Ch,    FILE * _File);
  int __cdecl vfprintf(   FILE * _File,     const char * _Format, va_list _ArgList);

  int __cdecl vfprintf_s(   FILE * _File,     const char * _Format, va_list _ArgList);
#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl vprintf(    const char * _Format, va_list _ArgList);

  int __cdecl vprintf_s(    const char * _Format, va_list _ArgList);
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
   int __cdecl vsnprintf(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

  int __cdecl vsnprintf_s(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _vsnprintf_s(    char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
  int __cdecl _snprintf(   char *_Dest,   size_t _Count,     const char * _Format, ...);   int __cdecl _vsnprintf(   char *_Dest,   size_t _Count,     const char * _Format, va_list _Args);
#pragma warning(pop)

 int __cdecl vsprintf_s(    char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, va_list _ArgList);
#line 363 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Dest)[_Size],     const char * _Format, va_list _Args) { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
  int __cdecl sprintf(  char *_Dest,  const char * _Format, ...);   int __cdecl vsprintf(  char *_Dest,  const char * _Format, va_list _Args);
#pragma warning(pop)
  int __cdecl _vscprintf(    const char * _Format, va_list _ArgList);
  int __cdecl _snprintf_c(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, ...);
  int __cdecl _vsnprintf_c(  char *_DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

  int __cdecl _fprintf_p(   FILE * _File,     const char * _Format, ...);
  int __cdecl _printf_p(    const char * _Format, ...);
  int __cdecl _sprintf_p(    char * _Dst,   size_t _MaxCount,     const char * _Format, ...);
  int __cdecl _vfprintf_p(   FILE * _File,     const char * _Format, va_list _ArgList);
  int __cdecl _vprintf_p(    const char * _Format, va_list _ArgList);
  int __cdecl _vsprintf_p(    char * _Dst,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
  int __cdecl _scprintf_p(    const char * _Format, ...);
  int __cdecl _vscprintf_p(    const char * _Format, va_list _ArgList);
 int __cdecl _set_printf_count_output(  int _Value);
 int __cdecl _get_printf_count_output();

  int __cdecl _printf_l(    const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _printf_p_l(    const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _printf_s_l(    const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _vprintf_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vprintf_p_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vprintf_s_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);

  int __cdecl _fprintf_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _fprintf_p_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _fprintf_s_l(   FILE * _File,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _vfprintf_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vfprintf_p_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vfprintf_s_l(   FILE * _File,    const char * _Format,    _locale_t _Locale, va_list _ArgList);

   int __cdecl _sprintf_l(   char * _DstBuf,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _sprintf_p_l(    char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _sprintf_s_l(    char * _DstBuf,   size_t _DstSize,     const char * _Format,    _locale_t _Locale, ...);
   int __cdecl _vsprintf_l(   char * _DstBuf,    const char * _Format,    _locale_t, va_list _ArgList);
  int __cdecl _vsprintf_p_l(    char * _DstBuf,   size_t _MaxCount,     const char* _Format,    _locale_t _Locale,  va_list _ArgList);
  int __cdecl _vsprintf_s_l(    char * _DstBuf,   size_t _DstSize,     const char * _Format,    _locale_t _Locale, va_list _ArgList);

  int __cdecl _scprintf_l(    const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _scprintf_p_l(    const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _vscprintf_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vscprintf_p_l(    const char * _Format,    _locale_t _Locale, va_list _ArgList);

   int __cdecl _snprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _snprintf_c_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
  int __cdecl _snprintf_s_l(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, ...);
   int __cdecl _vsnprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vsnprintf_c_l(  char * _DstBuf,   size_t _MaxCount, const char *,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vsnprintf_s_l(    char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char* _Format,   _locale_t _Locale, va_list _ArgList);



/* wide function prototypes, also declared in wchar.h  */



#line 423 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"




  FILE * __cdecl _wfsopen(   const wchar_t * _Filename,    const wchar_t * _Mode,   int _ShFlag);
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  wint_t __cdecl fgetwc(   FILE * _File);
  wint_t __cdecl _fgetwchar(void);
  wint_t __cdecl fputwc(  wchar_t _Ch,    FILE * _File);
  wint_t __cdecl _fputwchar(  wchar_t _Ch);
  wint_t __cdecl getwc(   FILE * _File);
  wint_t __cdecl getwchar(void);
  wint_t __cdecl putwc(  wchar_t _Ch,    FILE * _File);
  wint_t __cdecl putwchar(  wchar_t _Ch);
  wint_t __cdecl ungetwc(  wint_t _Ch,    FILE * _File);

  wchar_t * __cdecl fgetws(    wchar_t * _Dst,   int _SizeInWords,    FILE * _File);
  int __cdecl fputws(   const wchar_t * _Str,    FILE * _File);
  wchar_t * __cdecl _getws_s(    wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(wchar_t (&_String)[_Size]) { return _getws_s(_String, _Size); } }
  wchar_t * __cdecl _getws(  wchar_t *_String);
  int __cdecl _putws(   const wchar_t * _Str);

  int __cdecl fwprintf(   FILE * _File,     const wchar_t * _Format, ...);

  int __cdecl fwprintf_s(   FILE * _File,     const wchar_t * _Format, ...);
#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl wprintf(    const wchar_t * _Format, ...);

  int __cdecl wprintf_s(    const wchar_t * _Format, ...);
#line 455 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _scwprintf(    const wchar_t * _Format, ...);
  int __cdecl vfwprintf(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);

  int __cdecl vfwprintf_s(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);
#line 460 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl vwprintf(    const wchar_t * _Format, va_list _ArgList);

  int __cdecl vwprintf_s(    const wchar_t * _Format, va_list _ArgList);
#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


 int __cdecl swprintf_s(    wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, ...);
#line 468 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Dest)[_Size],     const wchar_t * _Format, ...) { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

 int __cdecl vswprintf_s(    wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);
#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) { return vswprintf_s(_Dest, _Size, _Format, _Args); } }

  int __cdecl _swprintf_c(    wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, ...);
  int __cdecl _vswprintf_c(    wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);

  int __cdecl _snwprintf_s(    wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, ...) { va_list _ArgList; ( __va_start(&_ArgList, _Format) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
  int __cdecl _vsnwprintf_s(    wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, va_list _Args) { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
  int __cdecl _snwprintf(   wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, ...);   int __cdecl _vsnwprintf(   wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

  int __cdecl _fwprintf_p(   FILE * _File,     const wchar_t * _Format, ...);
  int __cdecl _wprintf_p(    const wchar_t * _Format, ...);
  int __cdecl _vfwprintf_p(   FILE * _File,     const wchar_t * _Format, va_list _ArgList);
  int __cdecl _vwprintf_p(    const wchar_t * _Format, va_list _ArgList);
  int __cdecl _swprintf_p(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, ...);
  int __cdecl _vswprintf_p(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
  int __cdecl _scwprintf_p(    const wchar_t * _Format, ...);
  int __cdecl _vscwprintf_p(    const wchar_t * _Format, va_list _ArgList);

  int __cdecl _wprintf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _wprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _wprintf_s_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _vwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vwprintf_s_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

  int __cdecl _fwprintf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _fwprintf_p_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _fwprintf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _vfwprintf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vfwprintf_p_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vfwprintf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

  int __cdecl _swprintf_c_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _swprintf_p_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _swprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _vswprintf_c_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vswprintf_p_l(    wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vswprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

  int __cdecl _scwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _scwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _vscwprintf_p_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);

   int __cdecl _snwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _snwprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
   int __cdecl _vsnwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
  int __cdecl _vsnwprintf_s_l(    wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);










#line 535 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

/* we could end up with a double deprecation, disable warnings 4141 and 4996 */
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  int __cdecl _swprintf(   wchar_t *_Dest,     const wchar_t * _Format, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  int __cdecl _vswprintf(   wchar_t *_Dest,     const wchar_t * _Format, va_list _Args);
 __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  int __cdecl __swprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, ...);  __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  int __cdecl __vswprintf_l( wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"
/***
*swprintf.inl - inline definitions for (v)swprintf
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function definitions for (v)swprintf
*
*       [Public]
*
****/

#pragma once







#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"










#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( __va_start(&_Arglist, _Format) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( __va_start(&_Arglist, _Plocinfo) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int swprintf(   wchar_t * _String,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( __va_start(&_Arglist, _Format) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl vswprintf(   wchar_t * _String,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int _swprintf_l(   wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( __va_start(&_Arglist, _Plocinfo) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS."))  __inline int __cdecl _vswprintf_l(   wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"

#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\swprintf.inl"

#line 545 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
#line 546 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"













#line 560 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  wchar_t * __cdecl _wtempnam(   const wchar_t * _Directory,    const wchar_t * _FilePrefix);



#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  int __cdecl _vscwprintf(    const wchar_t * _Format, va_list _ArgList);
  int __cdecl _vscwprintf_l(    const wchar_t * _Format,    _locale_t _Locale, va_list _ArgList);
   int __cdecl fwscanf(   FILE * _File,     const wchar_t * _Format, ...);
   int __cdecl _fwscanf_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);

  int __cdecl fwscanf_s(   FILE * _File,     const wchar_t * _Format, ...);
#line 574 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _fwscanf_s_l(   FILE * _File,     const wchar_t * _Format,    _locale_t _Locale, ...);
   int __cdecl swscanf(   const wchar_t * _Src,     const wchar_t * _Format, ...);
   int __cdecl _swscanf_l(   const wchar_t * _Src,     const wchar_t * _Format,    _locale_t _Locale, ...);

  int __cdecl swscanf_s(   const wchar_t *_Src,     const wchar_t * _Format, ...);
#line 580 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _swscanf_s_l(   const wchar_t * _Src,     const wchar_t * _Format,    _locale_t _Locale, ...);
   int __cdecl _snwscanf(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
   int __cdecl _snwscanf_l(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
  int __cdecl _snwscanf_s(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
  int __cdecl _snwscanf_s_l(     const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,    _locale_t _Locale, ...);
   int __cdecl wscanf(    const wchar_t * _Format, ...);
   int __cdecl _wscanf_l(    const wchar_t * _Format,    _locale_t _Locale, ...);

  int __cdecl wscanf_s(    const wchar_t * _Format, ...);
#line 590 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
  int __cdecl _wscanf_s_l(    const wchar_t * _Format,    _locale_t _Locale, ...);
#pragma warning(pop)

  FILE * __cdecl _wfdopen(  int _FileHandle ,    const wchar_t * _Mode);
   FILE * __cdecl _wfopen(   const wchar_t * _Filename,    const wchar_t * _Mode);
  errno_t __cdecl _wfopen_s(     FILE ** _File,    const wchar_t * _Filename,    const wchar_t * _Mode);
   FILE * __cdecl _wfreopen(   const wchar_t * _Filename,    const wchar_t * _Mode,    FILE * _OldFile);
  errno_t __cdecl _wfreopen_s(     FILE ** _File,    const wchar_t * _Filename,    const wchar_t * _Mode,    FILE * _OldFile);





  FILE * __cdecl _wpopen(   const wchar_t *_Command,    const wchar_t * _Mode);
  int __cdecl _wremove(   const wchar_t * _Filename);
  errno_t __cdecl _wtmpnam_s(    wchar_t * _DstBuf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) { return _wtmpnam_s(_Buffer, _Size); } }
  wchar_t * __cdecl _wtmpnam(  wchar_t *_Buffer);

  wint_t __cdecl _fgetwc_nolock(   FILE * _File);
  wint_t __cdecl _fputwc_nolock(  wchar_t _Ch,    FILE * _File);
  wint_t __cdecl _ungetwc_nolock(  wint_t _Ch,    FILE * _File);






#line 619 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"
inline wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }   /* stdin */
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       /* stdout */
#line 624 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"










#line 635 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


#line 638 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


#line 641 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


/* Macro definitions */












#line 657 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"












 void __cdecl _lock_file(   FILE * _File);
 void __cdecl _unlock_file(   FILE * _File);



#line 675 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


  int __cdecl _fclose_nolock(   FILE * _File);
  int __cdecl _fflush_nolock(   FILE * _File);
  size_t __cdecl _fread_nolock(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,    FILE * _File);
  size_t __cdecl _fread_nolock_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,    FILE * _File);
  int __cdecl _fseek_nolock(   FILE * _File,   long _Offset,   int _Origin);
  long __cdecl _ftell_nolock(   FILE * _File);
  int __cdecl _fseeki64_nolock(   FILE * _File,   __int64 _Offset,   int _Origin);
  __int64 __cdecl _ftelli64_nolock(   FILE * _File);
  size_t __cdecl _fwrite_nolock(   const void * _DstBuf,   size_t _Size,   size_t _Count,    FILE * _File);
  int __cdecl _ungetc_nolock(  int _Ch,    FILE * _File);












#line 700 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"



/* Non-ANSI names for compatibility */







#line 712 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

  char * __cdecl tempnam(   const char * _Directory,    const char * _FilePrefix);



#line 718 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

   int __cdecl fcloseall(void);
   FILE * __cdecl fdopen(  int _FileHandle,    const char * _Format);
   int __cdecl fgetchar(void);
   int __cdecl fileno(  FILE * _File);
   int __cdecl flushall(void);
   int __cdecl fputchar(  int _Ch);
   int __cdecl getw(   FILE * _File);
   int __cdecl putw(  int _Ch,    FILE * _File);
   int __cdecl rmtmp(void);

#line 730 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


}
#line 734 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"


#pragma pack(pop)
#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

#line 740 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\stdio.h"

#line 2 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"

#line 1 "C:\\CUDA\\include\\cuPrintf.cu"
/*
	Copyright 2009 NVIDIA Corporation.  All rights reserved.

	NOTICE TO LICENSEE:   

	This source code and/or documentation ("Licensed Deliverables") are subject 
	to NVIDIA intellectual property rights under U.S. and international Copyright 
	laws.  

	These Licensed Deliverables contained herein is PROPRIETARY and CONFIDENTIAL 
	to NVIDIA and is being provided under the terms and conditions of a form of 
	NVIDIA software license agreement by and between NVIDIA and Licensee ("License 
	Agreement") or electronically accepted by Licensee.  Notwithstanding any terms 
	or conditions to the contrary in the License Agreement, reproduction or 
	disclosure of the Licensed Deliverables to any third party without the express 
	written consent of NVIDIA is prohibited.     

	NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, 
	NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THESE LICENSED 
	DELIVERABLES FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED 
	WARRANTY OF ANY KIND. NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE 
	LICENSED DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, 
	NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.   NOTWITHSTANDING ANY 
	TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, IN NO EVENT SHALL 
	NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, 
	OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,	WHETHER 
	IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF 
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THESE LICENSED DELIVERABLES.  

	U.S. Government End Users. These Licensed Deliverables are a "commercial item" 
	as that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
	"commercial computer  software"  and "commercial computer software documentation" 
	as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) and is provided to the 
	U.S. Government only as a commercial end item.  Consistent with 48 C.F.R.12.212 
	and 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all U.S. Government 
	End Users acquire the Licensed Deliverables with only those rights set forth 
	herein. 

	Any use of the Licensed Deliverables in individual and commercial software must 
	include, in the user documentation and internal comments to the code, the above 
	Disclaimer and U.S. Government End Users Notice.
 */

/*
 *	cuPrintf.cu
 *
 *	This is a printf command callable from within a kernel. It is set
 *	up so that output is sent to a memory buffer, which is emptied from
 *	the host side - but only after a cudaThreadSynchronize() on the host.
 *
 *	Currently, there is a limitation of around 200 characters of output
 *	and no more than 10 arguments to a single cuPrintf() call. Issue
 *	multiple calls if longer format strings are required.
 *
 *	It requires minimal setup, and is *NOT* optimised for performance.
 *	For example, writes are not coalesced - this is because there is an
 *	assumption that people will not want to printf from every single one
 *	of thousands of threads, but only from individual threads at a time.
 *
 *	Using this is simple - it requires one host-side call to initialise
 *	everything, and then kernels can call cuPrintf at will. Sample code
 *	is the easiest way to demonstrate:
 *
	#include "cuPrintf.cu"
 	
	__global__ void testKernel(int val)
	{
		cuPrintf("Value is: %d\n", val);
	}

	int main()
	{
		cudaPrintfInit();
		testKernel<<< 2, 3 >>>(10);
		cudaPrintfDisplay(stdout, true);
		cudaPrintfEnd();
        return 0;
	}
 *
 *	See the header file, "cuPrintf.cuh" for more info, especially
 *	arguments to cudaPrintfInit() and cudaPrintfDisplay();
 */




#line 1 "c:\\cuda\\include\\cuPrintf.cuh"
/*
	Copyright 2009 NVIDIA Corporation.  All rights reserved.

	NOTICE TO LICENSEE:   

	This source code and/or documentation ("Licensed Deliverables") are subject 
	to NVIDIA intellectual property rights under U.S. and international Copyright 
	laws.  

	These Licensed Deliverables contained herein is PROPRIETARY and CONFIDENTIAL 
	to NVIDIA and is being provided under the terms and conditions of a form of 
	NVIDIA software license agreement by and between NVIDIA and Licensee ("License 
	Agreement") or electronically accepted by Licensee.  Notwithstanding any terms 
	or conditions to the contrary in the License Agreement, reproduction or 
	disclosure of the Licensed Deliverables to any third party without the express 
	written consent of NVIDIA is prohibited.     

	NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, 
	NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THESE LICENSED 
	DELIVERABLES FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED 
	WARRANTY OF ANY KIND. NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE 
	LICENSED DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, 
	NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.   NOTWITHSTANDING ANY 
	TERMS OR CONDITIONS TO THE CONTRARY IN THE LICENSE AGREEMENT, IN NO EVENT SHALL 
	NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, 
	OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,	WHETHER 
	IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF 
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THESE LICENSED DELIVERABLES.  

	U.S. Government End Users. These Licensed Deliverables are a "commercial item" 
	as that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
	"commercial computer  software"  and "commercial computer software documentation" 
	as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) and is provided to the 
	U.S. Government only as a commercial end item.  Consistent with 48 C.F.R.12.212 
	and 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all U.S. Government 
	End Users acquire the Licensed Deliverables with only those rights set forth 
	herein. 

	Any use of the Licensed Deliverables in individual and commercial software must 
	include, in the user documentation and internal comments to the code, the above 
	Disclaimer and U.S. Government End Users Notice.
 */




/*
 *	This is the header file supporting cuPrintf.cu and defining both
 *	the host and device-side interfaces. See that file for some more
 *	explanation and sample use code. See also below for details of the
 *	host-side interfaces.
 *
 *  Quick sample code:
 *
	#include "cuPrintf.cu"
 	
	__global__ void testKernel(int val)
	{
		cuPrintf("Value is: %d\n", val);
	}

	int main()
	{
		cudaPrintfInit();
		testKernel<<< 2, 3 >>>(10);
		cudaPrintfDisplay(stdout, true);
		cudaPrintfEnd();
        return 0;
	}
 */

///////////////////////////////////////////////////////////////////////////////
// DEVICE SIDE
// External function definitions for device-side code

// Abuse of templates to simulate varargs
__declspec(__device__) int cuPrintf(const char *fmt);
template <typename T1> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1);
template <typename T1, typename T2> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2);
template <typename T1, typename T2, typename T3> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3);
template <typename T1, typename T2, typename T3, typename T4> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
template <typename T1, typename T2, typename T3, typename T4, typename T5> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);


//
//	cuPrintfRestrict
//
//	Called to restrict output to a given thread/block. Pass
//	the constant CUPRINTF_UNRESTRICTED to unrestrict output
//	for thread/block IDs. Note you can therefore allow
//	"all printfs from block 3" or "printfs from thread 2
//	on all blocks", or "printfs only from block 1, thread 5".
//
//	Arguments:
//		threadid - Thread ID to allow printfs from
//		blockid - Block ID to allow printfs from
//
//	NOTE: Restrictions last between invocations of
//	kernels unless cudaPrintfInit() is called again.
//

__declspec(__device__) void cuPrintfRestrict(int threadid, int blockid);



///////////////////////////////////////////////////////////////////////////////
// HOST SIDE
// External function definitions for host-side code

//
//	cudaPrintfInit
//
//	Call this once to initialise the printf system. If the output
//	file or buffer size needs to be changed, call cudaPrintfEnd()
//	before re-calling cudaPrintfInit().
//
//	The default size for the buffer is 1 megabyte. For CUDA
//	architecture 1.1 and above, the buffer is filled linearly and
//	is completely used;	however for architecture 1.0, the buffer
//	is divided into as many segments are there are threads, even
//	if some threads do not call cuPrintf().
//
//	Arguments:
//		bufferLen - Length, in bytes, of total space to reserve
//		            (in device global memory) for output.
//
//	Returns:
//		cudaSuccess if all is well.
//
extern "C" cudaError_t cudaPrintfInit(size_t bufferLen=1048576);   // 1-meg - that's enough for 4096 printfs by all threads put together

//
//	cudaPrintfEnd
//
//	Cleans up all memories allocated by cudaPrintfInit().
//	Call this at exit, or before calling cudaPrintfInit() again.
//
extern "C" void cudaPrintfEnd();

//
//	cudaPrintfDisplay
//
//	Dumps the contents of the output buffer to the specified
//	file pointer. If the output pointer is not specified,
//	the default "stdout" is used.
//
//	Arguments:
//		outputFP     - A file pointer to an output stream.
//		showThreadID - If "true", output strings are prefixed
//		               by "[blockid, threadid] " at output.
//
//	Returns:
//		cudaSuccess if all is well.
//
extern "C" cudaError_t cudaPrintfDisplay(void *outputFP=0, bool showThreadID=false);

#line 163 "c:\\cuda\\include\\cuPrintf.cuh"
#line 88 "C:\\CUDA\\include\\cuPrintf.cu"

#line 1 "C:\\CUDA\\include\\sm_11_atomic_functions.h"
/*
 * Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:   
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and 
 * international Copyright laws.  Users and possessors of this source code 
 * are hereby granted a nonexclusive, royalty-free license to use this code 
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE 
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR 
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH 
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL, 
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE 
 * OR PERFORMANCE OF THIS SOURCE CODE.  
 *
 * U.S. Government End Users.   This source code is a "commercial item" as 
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of 
 * "commercial computer  software"  and "commercial computer software 
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995) 
 * and is provided to the U.S. Government only as a commercial end item.  
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through 
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the 
 * source code with only those rights set forth herein. 
 *
 * Any use of this source code in individual and commercial software must 
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */
















































































































































































#line 212 "C:\\CUDA\\include\\sm_11_atomic_functions.h"
#line 90 "C:\\CUDA\\include\\cuPrintf.cu"
#line 91 "C:\\CUDA\\include\\cuPrintf.cu"

// This is the smallest amount of memory, per-thread, which is allowed.
// It is also the largest amount of space a single printf() can take up
const static int CUPRINTF_MAX_LEN = 256;

// This structure is used internally to track block/thread output restrictions.
typedef struct __declspec(align(8)) {
	int threadid;				// CUPRINTF_UNRESTRICTED for unrestricted
	int blockid;				// CUPRINTF_UNRESTRICTED for unrestricted
} cuPrintfRestriction;

// The main storage is in a global print buffer, which has a known
// start/end/length. These are atomically updated so it works as a
// circular buffer.
// Since the only control primitive that can be used is atomicAdd(),
// we cannot wrap the pointer as such. The actual address must be
// calculated from printfBufferPtr by mod-ing with printfBufferLength.
// For sm_10 architecture, we must subdivide the buffer per-thread
// since we do not even have an atomic primitive.
__declspec(__constant__) static char *globalPrintfBuffer = 0;         // Start of circular buffer (set up by host)
__declspec(__constant__) static int printfBufferLength = 0;              // Size of circular buffer (set up by host)
__declspec(__device__) static cuPrintfRestriction restrictRules;         // Output restrictions
__declspec(__device__) volatile static char *printfBufferPtr = 0;     // Current atomically-incremented non-wrapped offset

// This is the header preceeding all printf entries.
// NOTE: It *must* be size-aligned to the maximum entity size (size_t)
typedef struct __declspec(align(8)) {
    unsigned short magic;                   // Magic number says we're valid
    unsigned short fmtoffset;               // Offset of fmt string into buffer
    unsigned short blockid;                 // Block ID of author
    unsigned short threadid;                // Thread ID of author
} cuPrintfHeader;

// Special header for sm_10 architecture

typedef struct __declspec(align(16)) {
    unsigned short magic;                   // sm_10 specific magic number
    unsigned short unused;
    unsigned int thread_index;              // thread ID for this buffer
    unsigned int thread_buf_len;            // per-thread buffer length
    unsigned int offset;                    // most recent printf's offset
} cuPrintfHeaderSM10;


// Because we can't write an element which is not aligned to its bit-size,
// we have to align all sizes and variables on maximum-size boundaries.
// That means sizeof(double) in this case, but we'll use (long long) for
// better arch<1.3 support


// All our headers are prefixed with a magic number so we know they're ready



//
//  getNextPrintfBufPtr
//
//  Grabs a block of space in the general circular buffer, using an
//  atomic function to ensure that it's ours. We handle wrapping
//  around the circular buffer and return a pointer to a place which
//  can be written to.
//
//  Important notes:
//      1. We always grab CUPRINTF_MAX_LEN bytes
//      2. Because of 1, we never worry about wrapping around the end
//      3. Because of 1, printfBufferLength *must* be a factor of CUPRINTF_MAX_LEN
//
//  This returns a pointer to the place where we own.
//
__declspec(__device__) static char *getNextPrintfBufPtr()
{
    // Initialisation check
    if(!printfBufferPtr)
        return 0;

	// Thread/block restriction check
	if((restrictRules.blockid != -1) && (restrictRules.blockid != (blockIdx.x + gridDim.x*blockIdx.y)))
		return 0;
	if((restrictRules.threadid != -1) && (restrictRules.threadid != (threadIdx.x + blockDim.x*threadIdx.y + blockDim.x*blockDim.y*threadIdx.z)))
		return 0;

	// Conditional section, dependent on architecture











































#line 217 "C:\\CUDA\\include\\cuPrintf.cu"
    // Much easier with an atomic operation!
    size_t offset = atomicAdd((unsigned int *)&printfBufferPtr, CUPRINTF_MAX_LEN) - (size_t)globalPrintfBuffer;
    offset %= printfBufferLength;
    return globalPrintfBuffer + offset;
#line 222 "C:\\CUDA\\include\\cuPrintf.cu"
}


//
//  writePrintfHeader
//
//  Inserts the header for containing our UID, fmt position and
//  block/thread number. We generate it dynamically to avoid
//	issues arising from requiring pre-initialisation.
//
__declspec(__device__) static void writePrintfHeader(char *ptr, char *fmtptr)
{
    if(ptr)
    {
        cuPrintfHeader header;
        header.magic = (unsigned short)0xC811;
        header.fmtoffset = (unsigned short)(fmtptr - ptr);
        header.blockid = blockIdx.x + gridDim.x*blockIdx.y;
        header.threadid = threadIdx.x + blockDim.x*threadIdx.y + blockDim.x*blockDim.y*threadIdx.z;
        *(cuPrintfHeader *)(void *)ptr = header;
    }
}


//
//  cuPrintfStrncpy
//
//  This special strncpy outputs an aligned length value, followed by the
//  string. It then zero-pads the rest of the string until a 64-aligned
//  boundary. The length *includes* the padding. A pointer to the byte
//  just after the \0 is returned.
//
//  This function could overflow CUPRINTF_MAX_LEN characters in our buffer.
//  To avoid it, we must count as we output and truncate where necessary.
//
__declspec(__device__) static char *cuPrintfStrncpy(char *dest, const char *src, int n, char *end)
{
    // Initialisation and overflow check
    if(!dest || !src || (dest >= end))
        return 0;

    // Prepare to write the length specifier. We're guaranteed to have
    // at least "CUPRINTF_ALIGN_SIZE" bytes left because we only write out in
    // chunks that size, and CUPRINTF_MAX_LEN is aligned with CUPRINTF_ALIGN_SIZE.
    int *lenptr = (int *)(void *)dest;
    int len = 0;
    dest += sizeof(long long);

    // Now copy the string
    while(n--)
    {
        if(dest >= end)     // Overflow check
            break;

        len++;
        *dest++ = *src;
        if(*src++ == '\0')
            break;
    }

    // Now write out the padding bytes, and we have our length.
    while((dest < end) && (((long)dest & (sizeof(long long)-1)) != 0))
    {
        len++;
        *dest++ = 0;
    }
    *lenptr = len;
    return (dest < end) ? dest : 0;        // Overflow means return NULL
}


//
//  copyArg
//
//  This copies a length specifier and then the argument out to the
//  data buffer. Templates let the compiler figure all this out at
//  compile-time, making life much simpler from the programming
//  point of view. I'm assuimg all (const char *) is a string, and
//  everything else is the variable it points at. I'd love to see
//  a better way of doing it, but aside from parsing the format
//  string I can't think of one.
//
//  The length of the data type is inserted at the beginning (so that
//  the display can distinguish between float and double), and the
//  pointer to the end of the entry is returned.
//
__declspec(__device__) static char *copyArg(char *ptr, const char *arg, char *end)
{
    // Initialisation check
    if(!ptr || !arg)
        return 0;

    // strncpy does all our work. We just terminate.
    if((ptr = cuPrintfStrncpy(ptr, arg, CUPRINTF_MAX_LEN, end)) != 0)
        *ptr = 0;

    return ptr;
}

template <typename T>
__declspec(__device__) static char *copyArg(char *ptr, T &arg, char *end)
{
    // Initisalisation and overflow check. Alignment rules mean that
    // we're at least CUPRINTF_ALIGN_SIZE away from "end", so we only need
    // to check that one offset.
    if(!ptr || ((ptr+sizeof(long long)) >= end))
        return 0;

    // Write the length and argument
    *(int *)(void *)ptr = sizeof(arg);
    ptr += sizeof(long long);
    *(T *)(void *)ptr = arg;
    ptr += sizeof(long long);
    *ptr = 0;

    return ptr;
}


//
//  cuPrintf
//
//  Templated printf functions to handle multiple arguments.
//  Note we return the total amount of data copied, not the number
//  of characters output. But then again, who ever looks at the
//  return from printf() anyway?
//
//  The format is to grab a block of circular buffer space, the
//  start of which will hold a header and a pointer to the format
//  string. We then write in all the arguments, and finally the
//  format string itself. This is to make it easy to prevent
//  overflow of our buffer (we support up to 10 arguments, each of
//  which can be 12 bytes in length - that means that only the
//  format string (or a %s) can actually overflow; so the overflow
//  check need only be in the strcpy function.
//
//  The header is written at the very last because that's what
//  makes it look like we're done.
//
//  Errors, which are basically lack-of-initialisation, are ignored
//  in the called functions because NULL pointers are passed around
//

// All printf variants basically do the same thing, setting up the
// buffer, writing all arguments, then finalising the header. For
// clarity, we'll pack the code into some big macros.






// Posting an argument is easy



// After args are done, record start-of-fmt and write the fmt and header






__declspec(__device__) int cuPrintf(const char *fmt)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;
	bufptr = copyArg(bufptr, arg6, end);;
	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;
	bufptr = copyArg(bufptr, arg6, end);;
	bufptr = copyArg(bufptr, arg7, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;

	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;
	bufptr = copyArg(bufptr, arg6, end);;
	bufptr = copyArg(bufptr, arg7, end);;
	bufptr = copyArg(bufptr, arg8, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;
	bufptr = copyArg(bufptr, arg6, end);;
	bufptr = copyArg(bufptr, arg7, end);;
	bufptr = copyArg(bufptr, arg8, end);;
	bufptr = copyArg(bufptr, arg9, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}
template <typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10> __declspec(__device__) int cuPrintf(const char *fmt, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10)
{
	char *start, *end, *bufptr, *fmtstart; if((start = getNextPrintfBufPtr()) == 0) return 0; end = start + CUPRINTF_MAX_LEN; bufptr = start + sizeof(cuPrintfHeader);;
	    
	bufptr = copyArg(bufptr, arg1, end);;
	bufptr = copyArg(bufptr, arg2, end);;
	bufptr = copyArg(bufptr, arg3, end);;
	bufptr = copyArg(bufptr, arg4, end);;
	bufptr = copyArg(bufptr, arg5, end);;
	bufptr = copyArg(bufptr, arg6, end);;
	bufptr = copyArg(bufptr, arg7, end);;
	bufptr = copyArg(bufptr, arg8, end);;
	bufptr = copyArg(bufptr, arg9, end);;
	bufptr = copyArg(bufptr, arg10, end);;

	fmtstart = bufptr; end = cuPrintfStrncpy(bufptr, fmt, CUPRINTF_MAX_LEN, end); writePrintfHeader(start, end ? fmtstart : 0); return end ? (int)(end - start) : 0;;
}





//
//	cuPrintfRestrict
//
//	Called to restrict output to a given thread/block.
//	We store the info in "restrictRules", which is set up at
//	init time by the host. It's not the cleanest way to do this
//	because it means restrictions will last between
//	invocations, but given the output-pointer continuity,
//	I feel this is reasonable.
//
__declspec(__device__) void cuPrintfRestrict(int threadid, int blockid)
{
    int thread_count = blockDim.x * blockDim.y * blockDim.z;
	if(((threadid < thread_count) && (threadid >= 0)) || (threadid == -1))
		restrictRules.threadid = threadid;

	int block_count = gridDim.x * gridDim.y;
	if(((blockid < block_count) && (blockid >= 0)) || (blockid == -1))
		restrictRules.blockid = blockid;
}


///////////////////////////////////////////////////////////////////////////////
// HOST SIDE


static FILE *printf_fp;

static char *printfbuf_start=0;
static char *printfbuf_device=0;
static int printfbuf_len=0;


//
//  outputPrintfData
//
//  Our own internal function, which takes a pointer to a data buffer
//  and passes it through libc's printf for output.
//
//  We receive the formate string and a pointer to where the data is
//  held. We then run through and print it out.
//
//  Returns 0 on failure, 1 on success
//
static int outputPrintfData(char *fmt, char *data)
{
    // Format string is prefixed by a length that we don't need
    fmt += sizeof(long long);

    // Now run through it, printing everything we can. We must
    // run to every % character, extract only that, and use printf
    // to format it.
    char *p = strchr(fmt, '%');
    while(p != 0)
    {
        // Print up to the % character
        *p = '\0';
        fputs(fmt, printf_fp);
        *p = '%';           // Put back the %

        // Now handle the format specifier
        char *format = p++;         // Points to the '%'
        p += strcspn(p, "%cdiouxXeEfgGaAnps");
        if(*p == '\0')              // If no format specifier, print the whole thing
        {
            fmt = format;
            break;
        }

        // Cut out the format bit and use printf to print it. It's prefixed
        // by its length.
        int arglen = *(int *)data;
        if(arglen > CUPRINTF_MAX_LEN)
        {
            fputs("Corrupt printf buffer data - aborting\n", printf_fp);
            return 0;
        }

        data += sizeof(long long);
        
        char specifier = *p++;
        char c = *p;        // Store for later
        *p = '\0';
        switch(specifier)
        {
            // These all take integer arguments
            case 'c':
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
            case 'X':
            case 'p':
                fprintf(printf_fp, format, *((int *)data));
                break;

            // These all take double arguments
            case 'e':
            case 'E':
            case 'f':
            case 'g':
            case 'G':
            case 'a':
            case 'A':
                if(arglen == 4)     // Float vs. Double thing
                    fprintf(printf_fp, format, *((float *)data));
                else
                    fprintf(printf_fp, format, *((double *)data));
                break;

            // Strings are handled in a special way
            case 's':
                fprintf(printf_fp, format, (char *)data);
                break;

            // % is special
            case '%':
                fprintf(printf_fp, "%%");
                break;

            // Everything else is just printed out as-is
            default:
                fprintf(printf_fp, format);
                break;
        }
        data += sizeof(long long);         // Move on to next argument
        *p = c;                     // Restore what we removed
        fmt = p;                    // Adjust fmt string to be past the specifier
        p = strchr(fmt, '%');       // and get the next specifier
    }

    // Print out the last of the string
    fputs(fmt, printf_fp);
    return 1;
}


//
//  doPrintfDisplay
//
//  This runs through the blocks of CUPRINTF_MAX_LEN-sized data, calling the
//  print function above to display them. We've got this separate from
//  cudaPrintfDisplay() below so we can handle the SM_10 architecture
//  partitioning.
//
static int doPrintfDisplay(int headings, int clear, char *bufstart, char *bufend, char *bufptr, char *endptr)
{
    // Grab, piece-by-piece, each output element until we catch
    // up with the circular buffer end pointer
    int printf_count=0;
    char printfbuf_local[CUPRINTF_MAX_LEN+1];
    printfbuf_local[CUPRINTF_MAX_LEN] = '\0';

    while(bufptr != endptr)
    {
        // Wrap ourselves at the end-of-buffer
        if(bufptr == bufend)
            bufptr = bufstart;

        // Adjust our start pointer to within the circular buffer and copy a block.
        cudaMemcpy(printfbuf_local, bufptr, CUPRINTF_MAX_LEN, cudaMemcpyDeviceToHost);

        // If the magic number isn't valid, then this write hasn't gone through
        // yet and we'll wait until it does (or we're past the end for non-async printfs).
        cuPrintfHeader *hdr = (cuPrintfHeader *)printfbuf_local;
        if((hdr->magic != (unsigned short)0xC811) || (hdr->fmtoffset >= CUPRINTF_MAX_LEN))
        {
            //fprintf(printf_fp, "Bad magic number in printf header\n");
            break;
        }

        // Extract all the info and get this printf done
        if(headings)
            fprintf(printf_fp, "[%d, %d]: ", hdr->blockid, hdr->threadid);
        if(hdr->fmtoffset == 0)
            fprintf(printf_fp, "printf buffer overflow\n");
        else if(!outputPrintfData(printfbuf_local+hdr->fmtoffset, printfbuf_local+sizeof(cuPrintfHeader)))
            break;
        printf_count++;

        // Clear if asked
        if(clear)
            cudaMemset(bufptr, 0, CUPRINTF_MAX_LEN);

        // Now advance our start location, because we're done, and keep copying
        bufptr += CUPRINTF_MAX_LEN;
    }

    return printf_count;
}


//
//  cudaPrintfInit
//
//  Takes a buffer length to allocate, creates the memory on the device and
//  returns a pointer to it for when a kernel is called. It's up to the caller
//  to free it.
//
extern "C" cudaError_t cudaPrintfInit(size_t bufferLen)
{
    // Fix up bufferlen to be a multiple of CUPRINTF_MAX_LEN
    bufferLen = (bufferLen < CUPRINTF_MAX_LEN) ? CUPRINTF_MAX_LEN : bufferLen;
    if((bufferLen % CUPRINTF_MAX_LEN) > 0)
        bufferLen += (CUPRINTF_MAX_LEN - (bufferLen % CUPRINTF_MAX_LEN));
    printfbuf_len = (int)bufferLen;

    // Allocate a print buffer on the device and zero it
    if(cudaMalloc((void **)&printfbuf_device, printfbuf_len) != cudaSuccess)
		return cudaErrorInitializationError;
    cudaMemset(printfbuf_device, 0, printfbuf_len);
    printfbuf_start = printfbuf_device;         // Where we start reading from

	// No restrictions to begin with
	cuPrintfRestriction restrict;
	restrict.threadid = restrict.blockid = -1;
	cudaMemcpyToSymbol(restrictRules, &restrict, sizeof(restrict));

    // Initialise the buffer and the respective lengths/pointers.
    cudaMemcpyToSymbol(globalPrintfBuffer, &printfbuf_device, sizeof(char *));
    cudaMemcpyToSymbol(printfBufferPtr, &printfbuf_device, sizeof(char *));
    cudaMemcpyToSymbol(printfBufferLength, &printfbuf_len, sizeof(printfbuf_len));

    return cudaSuccess;
}


//
//  cudaPrintfEnd
//
//  Frees up the memory which we allocated
//
extern "C" void cudaPrintfEnd()
{
    if(!printfbuf_start || !printfbuf_device)
        return;

    cudaFree(printfbuf_device);
    printfbuf_start = printfbuf_device = 0;
}


//
//  cudaPrintfDisplay
//
//  Each call to this function dumps the entire current contents
//	of the printf buffer to the pre-specified FILE pointer. The
//	circular "start" pointer is advanced so that subsequent calls
//	dumps only new stuff.
//
//  In the case of async memory access (via streams), call this
//  repeatedly to keep trying to empty the buffer. If it's a sync
//  access, then the whole buffer should empty in one go.
//
//	Arguments:
//		outputFP     - File descriptor to output to (NULL => stdout)
//		showThreadID - If true, prints [block,thread] before each line
//
extern "C" cudaError_t cudaPrintfDisplay(void *outputFP, bool showThreadID)
{
	printf_fp = (FILE *)((outputFP == 0) ? (&__iob_func()[1]) : outputFP);

    // For now, we force "synchronous" mode which means we're not concurrent
	// with kernel execution. This also means we don't need clearOnPrint.
	// If you're patching it for async operation, here's where you want it.
    bool sync_printfs = true;
	bool clearOnPrint = false;

    // Initialisation check
    if(!printfbuf_start || !printfbuf_device || !printf_fp)
        return cudaErrorMissingConfiguration;

    // To determine which architecture we're using, we read the
    // first short from the buffer - it'll be the magic number
    // relating to the version.
    unsigned short magic;
    cudaMemcpy(&magic, printfbuf_device, sizeof(unsigned short), cudaMemcpyDeviceToHost);

    // For SM_10 architecture, we've split our buffer into one-per-thread.
    // That means we must do each thread block separately. It'll require
    // extra reading. We also, for now, don't support async printfs because
    // that requires tracking one start pointer per thread.
    if(magic == 0xC810)
    {
        sync_printfs = true;
	    clearOnPrint = false;
        int blocklen = 0;
        char *blockptr = printfbuf_device;
        while(blockptr < (printfbuf_device + printfbuf_len))
        {
            cuPrintfHeaderSM10 hdr;
            cudaMemcpy(&hdr, blockptr, sizeof(hdr), cudaMemcpyDeviceToHost);

            // We get our block-size-step from the very first header
            if(hdr.thread_buf_len != 0)
                blocklen = hdr.thread_buf_len;

            // No magic number means no printfs from this thread
            if(hdr.magic != 0xC810)
            {
                if(blocklen == 0)
                {
                    fprintf(printf_fp, "No printf headers found at all!\n");
                    break;                              // No valid headers!
                }
                blockptr += blocklen;
                continue;
            }

            // "offset" is non-zero then we can print the block contents
            if(hdr.offset > 0)
            {
                // For synchronous printfs, we must print from endptr->bufend, then from start->end
                if(sync_printfs)
                    doPrintfDisplay(showThreadID, clearOnPrint, blockptr+CUPRINTF_MAX_LEN, blockptr+hdr.thread_buf_len, blockptr+hdr.offset+CUPRINTF_MAX_LEN, blockptr+hdr.thread_buf_len);
                doPrintfDisplay(showThreadID, clearOnPrint, blockptr+CUPRINTF_MAX_LEN, blockptr+hdr.thread_buf_len, blockptr+CUPRINTF_MAX_LEN, blockptr+hdr.offset+CUPRINTF_MAX_LEN);
            }

            // Move on to the next block and loop again
            blockptr += hdr.thread_buf_len;
        }
    }
    // For SM_11 and up, everything is a single buffer and it's simple
    else if(magic == (unsigned short)0xC811)
    {
	    // Grab the current "end of circular buffer" pointer.
        char *printfbuf_end = 0;
        cudaMemcpyFromSymbol(&printfbuf_end, printfBufferPtr, sizeof(char *));

        // Adjust our starting and ending pointers to within the block
        char *bufptr = ((printfbuf_start - printfbuf_device) % printfbuf_len) + printfbuf_device;
        char *endptr = ((printfbuf_end - printfbuf_device) % printfbuf_len) + printfbuf_device;

        // For synchronous (i.e. after-kernel-exit) printf display, we have to handle circular
        // buffer wrap carefully because we could miss those past "end".
        if(sync_printfs)
            doPrintfDisplay(showThreadID, clearOnPrint, printfbuf_device, printfbuf_device+printfbuf_len, endptr, printfbuf_device+printfbuf_len);
        doPrintfDisplay(showThreadID, clearOnPrint, printfbuf_device, printfbuf_device+printfbuf_len, bufptr, endptr);

        printfbuf_start = printfbuf_end;
    }
    else
        ;//printf("Bad magic number in cuPrintf buffer header\n");

    // If we were synchronous, then we must ensure that the memory is cleared on exit
    // otherwise another kernel launch with a different grid size could conflict.
    if(sync_printfs)
        cudaMemset(printfbuf_device, 0, printfbuf_len);

    return cudaSuccess;
}

// Cleanup





#line 880 "C:\\CUDA\\include\\cuPrintf.cu"

#line 4 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"
/***
*float.h - constants for floating point values
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/


#pragma once
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtwrn.h"
/***
*crtwrn.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the IDs and messages for warnings
*       in the CRT headers.
*
****/

#pragma once




#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtdefs.h"
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */ 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtwrn.h"








/*
A warning is a 4-digit ID number (_CRTWRN_WNUMBER_*) 
followed by a message (_CRTWRN_MESSAGE_*)
Emit a warning by adding the following code to the header file:
    #pragma _CRT_WARNING( id )
*/

/* NAME */
/* #pragma _CRT_WARNING( NAME ) */
/* #define _CRTWRN_WNUMBER_NAME  9999 */
/* #define _CRTWRN_MESSAGE_NAME  description */

/* _VCCLRIT_DEPRECATED */
/* #pragma _CRT_WARNING( _VCCLRIT_DEPRECATED ) */



/* _EXPLICIT_KEYWORD_ */
/* #pragma _CRT_WARNING( _EXPLICIT_KEYWORD ) */




/* _CANNOT_USE_32BIT_TIME_T */
/* #pragma _CRT_WARNING( _NO_32BIT_TIME_T ) */




/* _NO_SPECIAL_TRANSFER */
/* #pragma _CRT_WARNING( _NO_SPECIAL_TRANSFER ) */




/* _NO_ITERATOR_DEBUGGING */
/* #pragma _CRT_WARNING( _NO_ITERATOR_DEBUGGING ) */





/* _CLR_STATIC_CPPLIB */
/* #pragma _CRT_WARNING( _CLR_AND_STATIC_CPPLIB ) */




#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\crtwrn.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

/* Define _CRT_MANAGED_FP_DEPRECATE */






#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"


extern "C" {
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"







































/* Function prototypes */

/* Reading or writing the floating point control/status words is not supported in managed code */

  unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
   unsigned int __cdecl _controlfp(  unsigned int _NewValue,  unsigned int _Mask);
#pragma warning(pop)
  void __cdecl _set_controlfp(  unsigned int _NewValue,   unsigned int _Mask);
  errno_t __cdecl _controlfp_s(  unsigned int *_CurrentState,   unsigned int _NewValue,   unsigned int _Mask);
  unsigned int __cdecl _statusfp(void);
  void __cdecl _fpreset(void);



#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"




/*
 * Abstract User Status Word bit definitions
 */








/*
 * New Control Bit that specifies the ambiguity in control word.
 */



/*
 * Abstract User Control Word Mask and bit definitions
 */














/*
 * i386 specific definitions
 */









/*
 * RISC specific definitions
 */







/* initial Control Word value */





#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"



#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"



#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

  unsigned int __cdecl _control87(  unsigned int _NewValue,  unsigned int _Mask);



#line 179 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

/* Global variable holding floating point error code */


  extern int * __cdecl __fpecode(void);



#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

/* invalid subconditions (_SW_INVALID also set) */






/*  Floating point error signals and return codes */
















/* IEEE recommended functions */






  double __cdecl _scalb(  double _X,   long _Y);
  double __cdecl _logb(  double _X);
  double __cdecl _nextafter(  double _X,   double _Y);
  int    __cdecl _finite(  double _X);
  int    __cdecl _isnan(  double _X);
  int    __cdecl _fpclass(  double _X);


  float __cdecl _scalbf(  float _X,   long _Y);
#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"















/* Non-ANSI names for compatibility */





  void __cdecl fpreset(void);





























































#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"


}
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"

#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\include\\float.h"
#line 5 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"
#line 1 "c:\\users\\tio\\documents\\visual studio 2008\\projects\\neo\\neo\\kernels.cu"






const int L_SIZE = 16;
const int N_POINTS = L_SIZE*L_SIZE;


__declspec(__global__) void fillU(void* r_data, void* u_data){
	
	float3* r = (float3*) r_data;
	
	
	
	float* u = (float*) u_data;

	int i=blockIdx.x;
	int j=blockIdx.y;

	float r_i[3] = {r[i].x,r[i].y,r[i].z};
	float r_j[3] = {r[j].x,r[j].y,r[j].z};
	
	float r1= sqrt(pow(r_i[0]-r_j[0],2) + pow(r_i[1]-r_j[1],2) + pow(r_i[2]-r_j[2],2));
	
	//cuPrintf("i=%f %f %f \n",r[i].x,r[i].y,r[i].z);
	//cuPrintf("j=%f %f %f \n",r[j].x,r[j].y,r[j].z);

	int alpha=threadIdx.x;
	int beta=threadIdx.y;
	
	int blockSize = blockDim.x*blockDim.y;

	float d_alpha = r_i[alpha]-r_j[alpha];
	float d_beta = r_i[beta]-r_j[beta];

	

	u[blockSize*gridDim.x*i + blockSize*j + blockDim.x * alpha + beta] = (fabs(r1)<1.192092896e-07F?0:
		
		(3* d_alpha/r1 * d_beta/r1 - (alpha==beta?1:0) )/(r1*r1*r1));
	
		//cuPrintf("u:%f r1:%f d_alpha:%f d_beta:%f\n",u[blockSize*gridDim.x*i + blockSize*j + blockDim.x * alpha + beta],r1,d_alpha,d_beta);
	
	
}



// ate N_POINTS-1
__declspec(__global__) void calc_H(void* h,void* s, void* u){
	
	
	int i = threadIdx.x;
	
	float3* s_data=(float3*)s;
	float3* u_data=(float3*)u;
	float3* h_data=(float3*)h;

	int aux;
	for(int j=i+1,aux=((i*N_POINTS*3)+(j*3));j<N_POINTS;j++,aux+=3){

		h_data[i].x+= u_data[aux].x*s_data[j].x + u_data[aux].y*s_data[j].y + u_data[aux].z*s_data[j].z;
	
		h_data[i].y+= u_data[aux+1].x*s_data[j].x + u_data[aux+1].y*s_data[j].y + u_data[aux+1].z*s_data[j].z;
	
		h_data[i].z+= u_data[aux+2].x*s_data[j].x + u_data[aux+2].y*s_data[j].y + u_data[aux+2].z*s_data[j].z;
	
	}
	
}


__declspec(__global__) void calc_E(void* h, void* s, void* e){
	
	extern __declspec(__shared__) float tmp[];

	float3* h_data=(float3*)h;
	float3* s_data=(float3*)s;
	float* e_data=(float*)e;
		
	int tid = threadIdx.x;
	int i = blockIdx.x * blockDim.x + threadIdx.x;
	
	tmp[tid]=-1*(h_data[i].x * s_data[i].x) - (h_data[i].y * s_data[i].y) -
	 			(h_data[i].z * s_data[i].z);
 	__syncthreads();
	
	for(int s=1;s<blockDim.x;s*=2){
		
		if(tid % (2*s) ==0)	{		
			tmp[tid]+=tmp[tid+s];
		}
		__syncthreads();
	}
	if (tid==0)
		e_data[blockIdx.x]=tmp[0];

}

	
// atÃ© N_POINTS
__declspec(__global__) void calc_full_E(void* u, void* s, void* e){
	
	extern __declspec(__shared__) float tmp2[];

	float3* u_data=(float3*)u;
	float3* s_data=(float3*)s;
	float* e_data=(float*)e;
		
	int tid = threadIdx.x;
	
	tmp2[tid]=0;
	int aux=0;
	for(int j=0;j<N_POINTS*3;j+=3,aux++){
		if(j==tid)
			continue;
		tmp2[tid]-=		(s_data[aux].x * u_data[(tid*N_POINTS*3)+j].x * s_data[tid].x) -
						(s_data[aux].y * u_data[(tid*N_POINTS*3)+j].y * s_data[tid].x) - 
						(s_data[aux].z * u_data[(tid*N_POINTS*3)+j].z * s_data[tid].x) - 

						(s_data[aux].x * u_data[(tid*N_POINTS*3)+(j+1)].x * s_data[tid].y) - 
						(s_data[aux].y * u_data[(tid*N_POINTS*3)+(j+1)].y * s_data[tid].y) - 
						(s_data[aux].z * u_data[(tid*N_POINTS*3)+(j+1)].z * s_data[tid].y) - 

						(s_data[aux].x * u_data[(tid*N_POINTS*3)+(j+2)].x * s_data[tid].z) - 
						(s_data[aux].y * u_data[(tid*N_POINTS*3)+(j+2)].y * s_data[tid].z) - 
						(s_data[aux].z * u_data[(tid*N_POINTS*3)+(j+2)].z * s_data[tid].z);

	}
	
	
 	__syncthreads();
	for(int s=1;s<blockDim.x;s*=2){
//1		int index=2*s*tid;
		if(tid % (2*s) ==0)	tmp2[tid]+=tmp2[tid+s];
		
//1		if (index < blockIdx.x) tmp2[index] += tmp2[index+s];

		__syncthreads();
	}
	if (tid==0)
		e_data[1]=tmp2[0];
	

}
#line 6 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"
#line 1 "c:\\users\\tio\\documents\\visual studio 2008\\projects\\neo\\neo\\naive.h"





float U[N_POINTS][N_POINTS][3][3];

void fillR_CPU(float3 *r_cpu){
	int k,j;
	for(j=0; j< L_SIZE;j++){
		for(k=0; k< L_SIZE; k++) {
			r_cpu[ k + j*L_SIZE  ].x=(float)k;
			r_cpu[ k + j*L_SIZE  ].y=(float)j;
			r_cpu[ k + j*L_SIZE  ].z=0.f;
		}
	}
}

void fill_U2(float3 *r_h){
	int m,n,i,j;
	for(i=0;i<N_POINTS;i++){
		for(j = 0; j < N_POINTS;j++){
			
			if(i==j) {
				continue;
			}
			float d[3];
			float r1=0,r2=0,r3=0;
			
			d[0]=r_h[i].x-r_h[j].x;
			r2+=d[0]*d[0];

			d[1]=r_h[i].y-r_h[j].y;
			r2+=d[1]*d[1];

			d[2]=r_h[i].z-r_h[j].z;
			r2+=d[2]*d[2];

			
			r1=sqrt(r2);
			r3=pow(r1,3);
			
			for(m=0;m<3;m++){
				for(n=0;n<3;n++){
					U[i][j][m][n]=(3* d[m]/r1 * d[n]/r1 - (m==n?1:0) )/r3;
				}
			}
		}
	}
}


/*
void fill_U(float *u_cpu, float3* r_h){
	for(int i=0;i<N_POINTS;i++){
		for(int j = 0; j < N_POINTS;j++){

			if(i==j) {
				continue;
			}
			float d[3];
			float r1=0,r2=0,r3=0;

			d[0]=r_h[i].x-r_h[j].x;
			r2+=d[0]*d[0];

			d[1]=r_h[i].y-r_h[j].y;
			r2+=d[1]*d[1];

			d[2]=r_h[i].z-r_h[j].z;
			r2+=d[2]*d[2];

			r1=sqrt(r2);
			r3=pow(r1,3);

			for(int m=0;m<3;m++){
				for(int n=0;n<3;n++){
					u_cpu[i*9 * N_POINTS + j*9 + m*3 + n]=(3* d[m]/r1 * d[n]/r1 - (m==n?1:0) )/r3;
					//printf("%d\n",i*9 * N_POINTS + j*9 + m*3 + n);
				}
			}
		}
	}
}
*/


/*
for(int i=0;i<N_POINTS;i++){
	for(int j=0;j<N_POINTS;j++){
		for(int k=0;k<3;k++){
			for(int l=0;l<3;l++){
				printf("%f ",u_cpu[i*9 * N_POINTS + j*9 + k*3 + l]);
//				assert(u_h[i*9 * N_POINTS + j*9 + k*3 + l]==u_cpu[i*9 * N_POINTS + j*9 + k*3 + l]);
			}
			if(k==2)
			printf("\n ======= \n");
			else
				puts("");
		}
	}
}
*/
/*	// Faz print do u calculado no GPU
	for(int i=0;i<N_POINTS;i++){
		for(int j=0;j<N_POINTS;j++){
			for(int k=0;k<3;k++){
				for(int l=0;l<3;l++){
					printf("%f ",u_h[i*9 * N_POINTS + j*9 + k*3 + l]);
				}
				printf("\n");
			}
			printf("---------------\n");
	}
}
*/

/*
	// Faz print do U calculado no CPU
	// Assert falha devido a precsao do GPU ser maior do que CPU (?) - mais do que epsilon
	for(int i=0;i<N_POINTS;i++){
		for(int j=0;j<N_POINTS;j++){
			for(int k=0;k<3;k++){
				for(int l=0;l<3;l++){
					printf("%d\n",i*9 * N_POINTS + j*9 + k*3 + l);
					printf("%f - %f",u_h[i*9 * N_POINTS + j*9 + k*3 + l],U[i][j][k][l]);
					assert(fabs(u_h[i*9 * N_POINTS + j*9 + k*3 + l]-U[i][j][k][l]) < eps_f);
					
				}
				printf("\n");
			}
			printf("---------------\n");
	}
}
*/


/*   // Escreve em ordem incorrecta
puts("barra");

for(int i=0;i<N_POINTS*N_POINTS*3;i++){
	printf("%f %f %f\n",u_h[i],u_h[i+1],u_h[i+2]);
	if ((i+1)%3 == 0)
		puts("=======");


}

*/
#line 7 "c:/Users/tio/Documents/Visual Studio 2008/Projects/Neo/Neo/naive.cu"




//#define eps_f FLT_EPSILON




int main(int argc, char** argv){


	puts("Ola");

	if(argc < 2){
		puts("neoNbody: Usage: neoNbody NumberOfPoints [-d]");
		exit(0);
		}


	static int N_POINTS = atoi(argv[1]);


	if(!strcmp(argv[2],"-d"))
		cudaError_t status = cudaSuccess;


	float* u_CPU;
	u_CPU = (float*) malloc(sizeof(float) * 3 * 3 * N_POINTS * N_POINTS);

	float3* r_CPU;
	r_CPU = (float3*) malloc(sizeof(float3) * N_POINTS * N_POINTS);

	fillR_CPU(r_CPU);

	for(int i=0;i<N_POINTS;i++)
		printf("%f %f %f\n",r_CPU[i].x,r_CPU[i].y,r_CPU[i].z);

	}



	


//	size_t buff=9999999;
//	cudaPrintfInit(buff);

// ======================= Alloc memoria Host ======================




